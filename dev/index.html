<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CUBScout.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://gus-pendleton.github.io/CUBScout.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CUBScout.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gus-pendleton/CUBScout.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CUBScout"><a class="docs-heading-anchor" href="#CUBScout">CUBScout</a><a id="CUBScout-1"></a><a class="docs-heading-anchor-permalink" href="#CUBScout" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/gus-pendleton/CUBScout.jl">CUBScout</a>.</p><ul><li><a href="#CUBScout.example_data_path"><code>CUBScout.example_data_path</code></a></li><li><a href="#CUBScout.codon_dict"><code>CUBScout.codon_dict</code></a></li><li><a href="#CUBScout.all_cub"><code>CUBScout.all_cub</code></a></li><li><a href="#CUBScout.b"><code>CUBScout.b</code></a></li><li><a href="#CUBScout.enc"><code>CUBScout.enc</code></a></li><li><a href="#CUBScout.enc_p"><code>CUBScout.enc_p</code></a></li><li><a href="#CUBScout.find_seqs-Tuple{AbstractString, Regex}"><code>CUBScout.find_seqs</code></a></li><li><a href="#CUBScout.make_codon_dict"><code>CUBScout.make_codon_dict</code></a></li><li><a href="#CUBScout.mcb"><code>CUBScout.mcb</code></a></li><li><a href="#CUBScout.milc"><code>CUBScout.milc</code></a></li><li><a href="#CUBScout.scuo"><code>CUBScout.scuo</code></a></li><li><a href="#CUBScout.seq_descriptions-Tuple{AbstractString}"><code>CUBScout.seq_descriptions</code></a></li><li><a href="#CUBScout.seq_names-Tuple{AbstractString}"><code>CUBScout.seq_names</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="CUBScout.example_data_path" href="#CUBScout.example_data_path"><code>CUBScout.example_data_path</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">example_data_path</code></pre><p>The path to an example dataset, stored as an artifact within the package. This is an .fna file containing coding sequences from Bacillus subtilis subsp. subtilis str. 168, NCBI Accession # NC_000964.3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/codon_dict.jl#L80-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.codon_dict" href="#CUBScout.codon_dict"><code>CUBScout.codon_dict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">codon_dict</code></pre><p>The <code>codon_dict</code> type defines how codons are translated, and is essential for calculating codon usage bias as it identifies stop codons and each amino acid&#39;s degeneracy. A default codon dictionary is provided (<code>default_codon_dict</code>), or a user can make their own using the <code>make_codon_dict</code> function.</p><p><strong>Fields</strong></p><ul><li><code>codons</code>: the 64 codons, in alphabetical order</li><li><code>AA</code>: corresponding amino acid for each codon (64 entries long)</li><li><code>AA_nostops</code>: same as AA, but with stop codons removed</li><li><code>uniqueAA</code>: unique amino acid names including stop codons. Under a standard translation table, this is 21 amino acids long</li><li><code>uniqueAA</code>: same as uniqueAA, but with stop codons removed</li><li><code>uniqueI</code>: a vector of the same length as uniqueAA, containing vectors of the indices of each codon for that amino acid. For instance, the first entry corresponds to Lysine, and contains the vector <code>[1, 3]</code>, corresponding to the positions of codons AAA and AAG in the codons field</li><li><code>uniqueI_nostops</code>: same as uniqueI, but with stop codons removed</li><li><code>deg</code>: a vector of the same length as uniqueAA, containing the degeneracy for each amino acid.</li><li><code>deg_nostops</code>: same as deg, but with stop codons removed</li><li><code>stop_mask</code>: a Boolean vector of length 64 which is false for stop codons. This is used to remove stop codons when calculating codon usage bias.</li></ul><p><strong>Notes</strong></p><p>Generally, CUBScout users shouldn&#39;t need to interact with the <code>codon_dict</code> type, as the standard genetic code is applied by default. Details for constructing a custom <code>codon_dict</code> are documented under the <code>make_codon_dict</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/codon_dict.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.all_cub" href="#CUBScout.all_cub"><code>CUBScout.all_cub</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_cub(filepath::String, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)
all_cub(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)</code></pre><p>Calculate all codon usage bias measures at once. Because many measures require the same initial calculations, this is more efficient than calculating them individually.</p><p><strong>Arguments</strong></p><ul><li><code>filepath</code>: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it&#39;s assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>filepaths</code>: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). <code>CUBScout</code> is multithreaded; if there are multiple threads available, <code>CUBScout</code> will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it&#39;s never worth using more threads than the total number of files being analyzed. There are no quality checks, so it&#39;s assumed that each entry is an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>dict</code>: codon dictionary of type <code>codon_dict</code>. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using <code>make_codon_dict</code></li><li><code>ref_seqs</code>: by default, codon usage bias for each gene is calculated using the whole genome (&quot;self&quot;) as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, <code>ref_seqs</code> takes a named tuple in the form <code>(&quot;subset_name&quot; = Bool[],)</code>, where <code>Bool[]</code> is the same length as the number of sequences in your fasta file, and contains <code>true</code> for sequences you want as your reference subset and false for those you don&#39;t. You can use <code>find_seqs()</code> to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and <code>CUBScout</code> will return the calculated measure using each subset. If providing multiple filepaths and want custom reference sets, <code>ref_seqs</code> should be a vector of named tuples corresponding to the vector of filepaths.</li><li><code>rm_start</code>: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, <code>CUBScout</code> keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine&#39;s contribution to codon usage bias. If you set <code>rm_start</code> to <code>true</code>, the first codon of every sequence is simply discarded. This will also affect the gene&#39;s length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R&#39;s coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply <code>altstart_codon_dict</code> to the <code>dict</code> argument, and keep <code>rm_start</code> as <code>false</code>.</li><li><code>rm_stop</code>: whether to remove stop codons from calculations of codon usage bias.</li><li><code>threshold</code>: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set <code>threshold</code> to 0.</li><li><code>dataframe</code>: whether to format output as a dataframe. By default results are returned as vectors or named tuples (if the measure uses reference subsets). Setting <code>dataframe = true</code> will instead output a dataframe, though at a slight performance cost.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; all_cub(example_data_path) # Calculate all six codon usage measures on example dataset
(B = (self = [0.20912699220973896, 0.3289759448740455, 0.22365336363593893, 0.5391135258658497, 0.24919594143501034, 0.2880358413249049, 0.31200964304415874, 0.34858035204347476, 0.2455189361074733, 0.4690734561271221  …  0.3629137353834403, 0.3621330537227321, 0.4535285720373026, 0.3357858047622507, 0.28183191395624935, 0.2668809561422238, 0.22381338105820905, 0.4034837015709619, 0.3594626865160133, 0.3724863965444541],), ENC = (ENC = [56.787282202547104, 52.725946690067296, 59.287948966886226, 52.29668642771212, 55.26298060679466, 53.44161579771853, 53.05664789279207, 52.0481893503424, 57.20652070751575, 44.663140238417824  …  45.29372394963511, 56.05080191311106, 58.21406301324846, 56.258765647523546, 60.10693676603753, 50.30390962534221, 56.29539618087172, 55.229391962859935, 52.58401385627267, 60.19275631834157],), ENCP = (self = [61.0, 59.36979815371983, 60.7494622549966, 61.0, 61.0, 56.353402323266224, 55.025304341802055, 57.30607996896261, 61.0, 49.80272180663614  …  58.275539315744126, 61.0, 58.28913535421893, 61.0, 61.0, 59.45750784609185, 61.0, 59.947884174402645, 59.43051836466144, 61.0],), MCB = (self = [0.08721123763355611, 0.17833660522736233, 0.18968222510423902, 0.2401197552240717, 0.14986851474968427, 0.2726565434395838, 0.2463076527192269, 0.21311734597718654, 0.12911296594333618, 0.33880929702119683  …  0.20493351356705938, 0.1315657625271143, 0.218615505877176, 0.1589526915862505, 0.11884772940321076, 0.16599279317487328, 0.09899721758865292, 0.20119392008973744, 0.2227777749890099, 0.14183390310488245],), MILC = (self = [0.49482573202153163, 0.5839439121281993, 0.49947166558087047, 0.6354929447434434, 0.5439352548027006, 0.6104721251245075, 0.6256398806438782, 0.6228376952086359, 0.5355298113407091, 0.7832276821181443  …  0.5968814155010973, 0.5964500002803941, 0.5930680822246766, 0.5412999510428169, 0.49866919389111675, 0.5830959504630727, 0.5139438478694085, 0.6164434557282711, 0.6018041071661588, 0.48775477465069617],), SCUO = (SCUO = [0.14312092935182216, 0.19123738759808445, 0.09632387849329298, 0.34521070127179804, 0.1057438762588421, 0.12037900551695478, 0.18385815287727708, 0.1664666302173014, 0.1250230978515499, 0.26111178459557927  …  0.24222582971568635, 0.18936014934691786, 0.2261902142070406, 0.13257602419177947, 0.1403154693937287, 0.1545378175732701, 0.10969625791871884, 0.1840696872016822, 0.15616118648954513, 0.23591385815130636],))

julia&gt; all_cub(example_data_path, dataframe = true) # Get output in dataframe format
3801×8 DataFrame
  Row │ self_B    ENC      self_ENCP  self_MCB   self_MILC  SCUO       Identifier                         File           ⋯
      │ Float64   Float64  Float64    Float64    Float64    Float64    String                             String         ⋯
──────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────
    1 │ 0.209127  56.7873    61.0     0.0872112   0.494826  0.143121   lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustu ⋯
    2 │ 0.328976  52.7259    59.3698  0.178337    0.583944  0.191237   lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustu
    3 │ 0.223653  59.2879    60.7495  0.189682    0.499472  0.0963239  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustu
    4 │ 0.539114  52.2967    61.0     0.24012     0.635493  0.345211   lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustu
  ⋮   │    ⋮         ⋮         ⋮          ⋮          ⋮          ⋮                      ⋮                                 ⋱
 3799 │ 0.403484  55.2294    59.9479  0.201194    0.616443  0.18407    lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustu ⋯
 3800 │ 0.359463  52.584     59.4305  0.222778    0.601804  0.156161   lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustu
 3801 │ 0.372486  60.1928    61.0     0.141834    0.487755  0.235914   lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustu
                                                                                            1 column and 3794 rows omitted


julia&gt; ribosomal_genes = find_seqs(example_data_path, r&quot;ribosomal&quot;); # Get a vector which is true for ribosomal genes

julia&gt; all_cub(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,), dataframe = true) # Calculate all measures using ribosomal genes as a reference subset
3801×8 DataFrame
  Row │ ribosomal_B  ENC      ribosomal_ENCP  ribosomal_MCB  ribosomal_MILC  SCUO       Identifier                       ⋯
      │ Float64      Float64  Float64         Float64        Float64         Float64    String                           ⋯
──────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────
    1 │    0.274331  56.7873         61.0         0.142922         0.532406  0.143121   lcl|NC_000964.3_cds_NP_387882.1_ ⋯
    2 │    0.32069   52.7259         58.8882      0.179081         0.579498  0.191237   lcl|NC_000964.3_cds_NP_387883.1_
    3 │    0.255325  59.2879         56.4104      0.306192         0.541516  0.0963239  lcl|NC_000964.3_cds_NP_387885.1_
    4 │    0.546493  52.2967         61.0         0.296251         0.668068  0.345211   lcl|NC_000964.3_cds_NP_387886.2_
  ⋮   │      ⋮          ⋮           ⋮               ⋮              ⋮             ⋮                      ⋮                ⋱
 3799 │    0.406673  55.2294         56.5325      0.239881         0.636678  0.18407    lcl|NC_000964.3_cds_NP_391983.1_ ⋯
 3800 │    0.375857  52.584          55.6687      0.260092         0.623519  0.156161   lcl|NC_000964.3_cds_NP_391984.1_
 3801 │    0.437981  60.1928         61.0         0.197456         0.551733  0.235914   lcl|NC_000964.3_cds_NP_391985.1_
                                                                                           2 columns and 3794 rows omitted</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/CUB_measures.jl#L895-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.b" href="#CUBScout.b"><code>CUBScout.b</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">b(filepath::String, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)
b(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)</code></pre><p>Calculate B from Karlin and Mrazek, 1996. </p><p><strong>Arguments</strong></p><ul><li><code>filepath</code>: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it&#39;s assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>filepaths</code>: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). <code>CUBScout</code> is multithreaded; if there are multiple threads available, <code>CUBScout</code> will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it&#39;s never worth using more threads than the total number of files being analyzed. There are no quality checks, so it&#39;s assumed that each entry is an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>dict</code>: codon dictionary of type <code>codon_dict</code>. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using <code>make_codon_dict</code></li><li><code>ref_seqs</code>: by default, codon usage bias for each gene is calculated using the whole genome (&quot;self&quot;) as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, <code>ref_seqs</code> takes a named tuple in the form <code>(&quot;subset_name&quot; = Bool[],)</code>, where <code>Bool[]</code> is the same length as the number of sequences in your fasta file, and contains <code>true</code> for sequences you want as your reference subset and false for those you don&#39;t. You can use <code>find_seqs()</code> to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and <code>CUBScout</code> will return the calculated measure using each subset. If providing multiple filepaths and want custom reference sets, <code>ref_seqs</code> should be a vector of named tuples corresponding to the vector of filepaths.</li><li><code>rm_start</code>: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, <code>CUBScout</code> keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine&#39;s contribution to codon usage bias. If you set <code>rm_start</code> to <code>true</code>, the first codon of every sequence is simply discarded. This will also affect the gene&#39;s length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R&#39;s coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply <code>altstart_codon_dict</code> to the <code>dict</code> argument, and keep <code>rm_start</code> as <code>false</code>.</li><li><code>rm_stop</code>: whether to remove stop codons from calculations of codon usage bias.</li><li><code>threshold</code>: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set <code>threshold</code> to 0.</li><li><code>dataframe</code>: whether to format output as a dataframe. By default results are returned as vectors or named tuples (if the measure uses reference subsets). Setting <code>dataframe = true</code> will instead output a dataframe, though at a slight performance cost.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; result = b(example_data_path) # Run B on example dataset
(self = [0.20912699220973896, 0.3289759448740455, 0.22365336363593893, 0.5391135258658497, 0.24919594143501034, 0.2880358413249049, 0.31200964304415874, 0.34858035204347476, 0.2455189361074733, 0.4690734561271221  …  0.3629137353834403, 0.3621330537227321, 0.4535285720373026, 0.3357858047622507, 0.28183191395624935, 0.2668809561422238, 0.22381338105820905, 0.4034837015709619, 0.3594626865160133, 0.3724863965444541],)

julia&gt; result_300 = b(example_data_path, threshold = 300); # Increase threshold length

julia&gt; length(result.self)
3801

julia&gt; length(result_300.self)
1650

julia&gt; b(example_data_path, altstart_codon_dict) # Use alternative start codons
(self = [0.20897234061622738, 0.33515000264964157, 0.23659038285006437, 0.5444798345895256, 0.2510726777670733, 0.2931440715811394, 0.32097661134289895, 0.35705614480228676, 0.25452296343822073, 0.513313870450466  …  0.34414371567411556, 0.38229515825882665, 0.4592524704597901, 0.3399477982926337, 0.29297757306048133, 0.2680028918895221, 0.2168486105068708, 0.414543030746344, 0.3829702745346273, 0.39870546723886807],)

julia&gt; b(example_data_path, dataframe = true) # Get output in dataframe format
3801×3 DataFrame
  Row │ self      Identifier                         File                              
      │ Float64   String                             String                            
──────┼────────────────────────────────────────────────────────────────────────────────
    1 │ 0.209127  lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 0.328976  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 0.223653  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 0.539114  lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │    ⋮                      ⋮                                  ⋮
 3799 │ 0.403484  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 0.359463  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 0.372486  lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                      3794 rows omitted

julia&gt; all_genes = find_seqs(example_data_path, r&quot;&quot;); # Get a vector which is true for all genes

julia&gt; ribosomal_genes = find_seqs(example_data_path, r&quot;ribosomal&quot;); # Get a vector which is true for ribosomal genes

julia&gt; b(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,), dataframe = true) # Calculate B using ribosomal genes as a reference subset
3801×3 DataFrame
  Row │ ribosomal  Identifier                         File                              
      │ Float64    String                             String                            
──────┼─────────────────────────────────────────────────────────────────────────────────
    1 │  0.274331  lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │  0.32069   lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │  0.255325  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │  0.546493  lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │     ⋮                      ⋮                                  ⋮
 3799 │  0.406673  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │  0.375857  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │  0.437981  lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                       3794 rows omitted

julia&gt; b(example_data_path, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,), dataframe = true) # Calculate B using all genes and ribosomal genes as a reference subset
3801×4 DataFrame
  Row │ self      ribosomal  Identifier                         File                              
      │ Float64   Float64    String                             String                            
──────┼───────────────────────────────────────────────────────────────────────────────────────────
    1 │ 0.209127   0.274331  lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 0.328976   0.32069   lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 0.223653   0.255325  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 0.539114   0.546493  lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │    ⋮          ⋮                      ⋮                                  ⋮
 3799 │ 0.403484   0.406673  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 0.359463   0.375857  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 0.372486   0.437981  lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                                 3794 rows omitted</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/CUB_measures.jl#L2-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.enc" href="#CUBScout.enc"><code>CUBScout.enc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enc(filepath::String, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)
enc(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)</code></pre><p>Calculate ENC from Wright, 1990. </p><p><strong>Arguments</strong></p><ul><li><code>filepath</code>: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it&#39;s assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>filepaths</code>: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). <code>CUBScout</code> is multithreaded; if there are multiple threads available, <code>CUBScout</code> will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it&#39;s never worth using more threads than the total number of files being analyzed. There are no quality checks, so it&#39;s assumed that each entry is an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>dict</code>: codon dictionary of type <code>codon_dict</code>. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using <code>make_codon_dict</code></li><li><code>rm_start</code>: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, <code>CUBScout</code> keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine&#39;s contribution to codon usage bias. If you set <code>rm_start</code> to <code>true</code>, the first codon of every sequence is simply discarded. This will also affect the gene&#39;s length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R&#39;s coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply <code>altstart_codon_dict</code> to the <code>dict</code> argument, and keep <code>rm_start</code> as <code>false</code>.</li><li><code>rm_stop</code>: whether to remove stop codons from calculations of codon usage bias.</li><li><code>threshold</code>: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set <code>threshold</code> to 0.</li><li><code>dataframe</code>: whether to format output as a dataframe. By default results are returned as vectors or named tuples (if the measure uses reference subsets). Setting <code>dataframe = true</code> will instead output a dataframe, though at a slight performance cost.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; result = enc(example_data_path) # Run ENC on example dataset
3801-element Vector{Float64}:
 56.787282202547104
 52.725946690067296
 59.287948966886226
 52.29668642771212
 55.26298060679466
 53.44161579771853
  ⋮
 50.30390962534221
 56.29539618087172
 55.229391962859935
 52.58401385627267
 60.19275631834157

julia&gt; result_300 = enc(example_data_path, threshold = 300); # Increase threshold length

julia&gt; length(result)
3801

julia&gt; length(result_300)
1650

julia&gt; enc(example_data_path, altstart_codon_dict) # Use alternative start codons
3801-element Vector{Float64}:
 57.001523875733255
 52.86344589270121
 59.5010825383314
 52.24194738136219
 55.24666826718284
 53.61982170502906
  ⋮
 50.35028822163096
 56.28255588604824
 54.240934927898564
 52.24532168870545
 60.12152034674111

julia&gt; enc(example_data_path, dataframe = true) # Get output in dataframe format
3801×3 DataFrame
  Row │ ENC      Identifier                         File                              
      │ Float64  String                             String                            
──────┼───────────────────────────────────────────────────────────────────────────────
    1 │ 56.7873  lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 52.7259  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 59.2879  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 52.2967  lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │    ⋮                     ⋮                                  ⋮
 3799 │ 55.2294  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 52.584   lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 60.1928  lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                     3794 rows omitted</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/CUB_measures.jl#L155-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.enc_p" href="#CUBScout.enc_p"><code>CUBScout.enc_p</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enc_p(filepath::String, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)
enc_p(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)</code></pre><p>Calculate ENC&#39; from Novembre, 2002.</p><p><strong>Arguments</strong></p><ul><li><code>filepath</code>: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it&#39;s assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>filepaths</code>: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). <code>CUBScout</code> is multithreaded; if there are multiple threads available, <code>CUBScout</code> will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it&#39;s never worth using more threads than the total number of files being analyzed. There are no quality checks, so it&#39;s assumed that each entry is an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>dict</code>: codon dictionary of type <code>codon_dict</code>. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using <code>make_codon_dict</code></li><li><code>ref_seqs</code>: by default, codon usage bias for each gene is calculated using the whole genome (&quot;self&quot;) as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, <code>ref_seqs</code> takes a named tuple in the form <code>(&quot;subset_name&quot; = Bool[],)</code>, where <code>Bool[]</code> is the same length as the number of sequences in your fasta file, and contains <code>true</code> for sequences you want as your reference subset and false for those you don&#39;t. You can use <code>find_seqs()</code> to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and <code>CUBScout</code> will return the calculated measure using each subset. If providing multiple filepaths and want custom reference sets, <code>ref_seqs</code> should be a vector of named tuples corresponding to the vector of filepaths.</li><li><code>rm_start</code>: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, <code>CUBScout</code> keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine&#39;s contribution to codon usage bias. If you set <code>rm_start</code> to <code>true</code>, the first codon of every sequence is simply discarded. This will also affect the gene&#39;s length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R&#39;s coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply <code>altstart_codon_dict</code> to the <code>dict</code> argument, and keep <code>rm_start</code> as <code>false</code>.</li><li><code>rm_stop</code>: whether to remove stop codons from calculations of codon usage bias.</li><li><code>threshold</code>: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set <code>threshold</code> to 0.</li><li><code>dataframe</code>: whether to format output as a dataframe. By default results are returned as vectors or named tuples (if the measure uses reference subsets). Setting <code>dataframe = true</code> will instead output a dataframe, though at a slight performance cost.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; result = enc_p(example_data_path) # Run ENC&#39; on example dataset
(self = [61.0, 59.36979815371983, 60.7494622549966, 61.0, 61.0, 56.353402323266224, 55.025304341802055, 57.30607996896261, 61.0, 49.80272180663614  …  58.275539315744126, 61.0, 58.28913535421893, 61.0, 61.0, 59.45750784609185, 61.0, 59.947884174402645, 59.43051836466144, 61.0],)

julia&gt; result_300 = enc_p(example_data_path, threshold = 300); # Increase threshold length

julia&gt; length(result.self)
3801

julia&gt; length(result_300.self)
1650

julia&gt; enc_p(example_data_path, altstart_codon_dict) # Use alternative start codons
(self = [61.0, 59.25393167941246, 60.451328058538294, 61.0, 61.0, 56.577935943942954, 55.48412223261298, 57.35814028261265, 61.0, 48.78039661159036  …  58.93889392717741, 61.0, 59.1935848198233, 61.0, 61.0, 59.587859071790746, 61.0, 58.81213890142517, 59.40548501932952, 61.0],)

julia&gt; enc_p(example_data_path, dataframe = true) # Get output in dataframe format
3801×3 DataFrame
  Row │ self     Identifier                         File                              
      │ Float64  String                             String                            
──────┼───────────────────────────────────────────────────────────────────────────────
    1 │ 61.0     lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 59.3698  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 60.7495  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 61.0     lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │    ⋮                     ⋮                                  ⋮
 3799 │ 59.9479  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 59.4305  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 61.0     lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                     3794 rows omitted

julia&gt; all_genes = find_seqs(example_data_path, r&quot;&quot;); # Get a vector which is true for all genes

julia&gt; ribosomal_genes = find_seqs(example_data_path, r&quot;ribosomal&quot;); # Get a vector which is true for ribosomal genes

julia&gt; enc_p(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,), dataframe = true) # Calculate ENC&#39; using ribosomal genes as a reference subset
3801×3 DataFrame
  Row │ ribosomal  Identifier                         File                              
      │ Float64    String                             String                            
──────┼─────────────────────────────────────────────────────────────────────────────────
    1 │   61.0     lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │   58.8882  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │   56.4104  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │   61.0     lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │     ⋮                      ⋮                                  ⋮
 3799 │   56.5325  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │   55.6687  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │   61.0     lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                       3794 rows omitted

julia&gt; enc_p(example_data_path, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,), dataframe = true) # Calculate ENC&#39; using all genes and ribosomal genes as a reference subset
3801×4 DataFrame
  Row │ self     ribosomal  Identifier                         File                              
      │ Float64  Float64    String                             String                            
──────┼──────────────────────────────────────────────────────────────────────────────────────────
    1 │ 61.0       61.0     lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 59.3698    58.8882  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 60.7495    56.4104  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 61.0       61.0     lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │    ⋮         ⋮                      ⋮                                  ⋮
 3799 │ 59.9479    56.5325  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 59.4305    55.6687  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 61.0       61.0     lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                                3794 rows omitted
                                                                       </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/CUB_measures.jl#L273-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.find_seqs-Tuple{AbstractString, Regex}" href="#CUBScout.find_seqs-Tuple{AbstractString, Regex}"><code>CUBScout.find_seqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_seqs(path::AbstractString, match_pattern::Regex)</code></pre><p>Read a fasta file at <code>path</code> and query the <em>description</em> field for a given Regex <code>match_pattern</code>. These results can be supplied in either the reference tuples (for codon usage bias functions) or reference vectors (for expressivity measures).</p><p><strong>Examples</strong></p><p><code>jldoctest julia&gt; find_seqs(example_data_path, r&quot;ribosomal&quot;) 4237-element Vector{Bool}:  0  0  0  0  0  0  ⋮  0  0  0  0  1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/accessory_functions.jl#L158-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.make_codon_dict" href="#CUBScout.make_codon_dict"><code>CUBScout.make_codon_dict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_codon_dict(filepath::AbstractString, delimiter::AbstractChar = &#39;	&#39;)</code></pre><p>Make a custom codon dictionary for organisms with non-standard genetic code. <code>filepath</code> points to a delimited file with two columns and no header. the first column should be codons, and the second column their corresponding amino acid. Avoid spaces and special characters (e.g., write GlutamicAcid instead of Glutamic Acid). Stop codons can be coded as Stop, stop, STOP, or *. If delimited using any character outside of tab, supply the delimiter as the second argument as Char, not a string (e.g. <code>&#39;,&#39;</code> not <code>&quot;,&quot;</code>). <code>make_codon_dict</code> uses <code>readdlm</code> from <code>DelimitedFiles</code>; it&#39;s a good idea to check whether <code>readdlm</code> parses your file correctly before passing to <code>make_codon_dict</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_codon_dict = make_codon_dict(CUBScout.codon_dict_path)
codon_dict(BioSequences.LongSequence{BioSequences.DNAAlphabet{2}}[AAA, AAC, AAG, AAT, ACA, ACC, ACG, ACT, AGA, AGC  …  TCG, TCT, TGA, TGC, TGG, TGT, TTA, TTC, TTG, TTT], [&quot;Lysine&quot;, &quot;Asparagine&quot;, &quot;Lysine&quot;, &quot;Asparagine&quot;, &quot;Threonine&quot;, &quot;Threonine&quot;, &quot;Threonine&quot;, &quot;Threonine&quot;, &quot;Arginine&quot;, &quot;Serine&quot;  …  &quot;Serine&quot;, &quot;Serine&quot;, &quot;Stop&quot;, &quot;Cysteine&quot;, &quot;Tryptophan&quot;, &quot;Cysteine&quot;, &quot;Leucine&quot;, &quot;Phenylalanine&quot;, &quot;Leucine&quot;, &quot;Phenylalanine&quot;], [&quot;Lysine&quot;, &quot;Asparagine&quot;, &quot;Lysine&quot;, &quot;Asparagine&quot;, &quot;Threonine&quot;, &quot;Threonine&quot;, &quot;Threonine&quot;, &quot;Threonine&quot;, &quot;Arginine&quot;, &quot;Serine&quot;  …  &quot;Serine&quot;, &quot;Serine&quot;, &quot;Serine&quot;, &quot;Cysteine&quot;, &quot;Tryptophan&quot;, &quot;Cysteine&quot;, &quot;Leucine&quot;, &quot;Phenylalanine&quot;, &quot;Leucine&quot;, &quot;Phenylalanine&quot;], [&quot;Lysine&quot;, &quot;Asparagine&quot;, &quot;Threonine&quot;, &quot;Arginine&quot;, &quot;Serine&quot;, &quot;Isoleucine&quot;, &quot;Methionine&quot;, &quot;Glutamine&quot;, &quot;Histidine&quot;, &quot;Proline&quot;  …  &quot;Glutamicacid&quot;, &quot;Asparticacid&quot;, &quot;Alanine&quot;, &quot;Glycine&quot;, &quot;Valine&quot;, &quot;Stop&quot;, &quot;Tyrosine&quot;, &quot;Cysteine&quot;, &quot;Tryptophan&quot;, &quot;Phenylalanine&quot;], [&quot;Lysine&quot;, &quot;Asparagine&quot;, &quot;Threonine&quot;, &quot;Arginine&quot;, &quot;Serine&quot;, &quot;Isoleucine&quot;, &quot;Methionine&quot;, &quot;Glutamine&quot;, &quot;Histidine&quot;, &quot;Proline&quot;, &quot;Leucine&quot;, &quot;Glutamicacid&quot;, &quot;Asparticacid&quot;, &quot;Alanine&quot;, &quot;Glycine&quot;, &quot;Valine&quot;, &quot;Tyrosine&quot;, &quot;Cysteine&quot;, &quot;Tryptophan&quot;, &quot;Phenylalanine&quot;], Vector{Int32}[[1, 3], [2, 4], [5, 6, 7, 8], [9, 11, 25, 26, 27, 28], [10, 12, 53, 54, 55, 56], [13, 14, 16], [15], [17, 19], [18, 20], [21, 22, 23, 24]  …  [33, 35], [34, 36], [37, 38, 39, 40], [41, 42, 43, 44], [45, 46, 47, 48], [49, 51, 57], [50, 52], [58, 60], [59], [62, 64]], Vector{Int32}[[1, 3], [2, 4], [5, 6, 7, 8], [9, 11, 25, 26, 27, 28], [10, 12, 51, 52, 53, 54], [13, 14, 16], [15], [17, 19], [18, 20], [21, 22, 23, 24], [29, 30, 31, 32, 58, 60], [33, 35], [34, 36], [37, 38, 39, 40], [41, 42, 43, 44], [45, 46, 47, 48], [49, 50], [55, 57], [56], [59, 61]], Int32[2, 2, 4, 6, 6, 3, 1, 2, 2, 4  …  2, 2, 4, 4, 4, 3, 2, 2, 1, 2], Int32[2, 2, 4, 6, 6, 3, 1, 2, 2, 4, 6, 2, 2, 4, 4, 4, 2, 2, 1, 2], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  1, 1, 0, 1, 1, 1, 1, 1, 1, 1])

julia&gt; typeof(my_codon_dict)
codon_dict

julia&gt; fieldnames(codon_dict)
(:codons, :AA, :AA_nostops, :uniqueAA, :uniqueAA_nostops, :uniqueI, :uniqueI_nostops, :deg, :deg_nostops, :stop_mask)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/codon_dict.jl#L35-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.mcb" href="#CUBScout.mcb"><code>CUBScout.mcb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mcb(filepath::String, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)
mcb(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)</code></pre><p>Calculate MCB from Urutia and Hurst, 2001.</p><p><strong>Arguments</strong></p><ul><li><code>filepath</code>: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it&#39;s assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>filepaths</code>: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). <code>CUBScout</code> is multithreaded; if there are multiple threads available, <code>CUBScout</code> will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it&#39;s never worth using more threads than the total number of files being analyzed. There are no quality checks, so it&#39;s assumed that each entry is an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>dict</code>: codon dictionary of type <code>codon_dict</code>. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using <code>make_codon_dict</code></li><li><code>ref_seqs</code>: by default, codon usage bias for each gene is calculated using the whole genome (&quot;self&quot;) as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, <code>ref_seqs</code> takes a named tuple in the form <code>(&quot;subset_name&quot; = Bool[],)</code>, where <code>Bool[]</code> is the same length as the number of sequences in your fasta file, and contains <code>true</code> for sequences you want as your reference subset and false for those you don&#39;t. You can use <code>find_seqs()</code> to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and <code>CUBScout</code> will return the calculated measure using each subset. If providing multiple filepaths and want custom reference sets, <code>ref_seqs</code> should be a vector of named tuples corresponding to the vector of filepaths.</li><li><code>rm_start</code>: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, <code>CUBScout</code> keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine&#39;s contribution to codon usage bias. If you set <code>rm_start</code> to <code>true</code>, the first codon of every sequence is simply discarded. This will also affect the gene&#39;s length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R&#39;s coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply <code>altstart_codon_dict</code> to the <code>dict</code> argument, and keep <code>rm_start</code> as <code>false</code>.</li><li><code>rm_stop</code>: whether to remove stop codons from calculations of codon usage bias.</li><li><code>threshold</code>: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set <code>threshold</code> to 0.</li><li><code>dataframe</code>: whether to format output as a dataframe. By default results are returned as vectors or named tuples (if the measure uses reference subsets). Setting <code>dataframe = true</code> will instead output a dataframe, though at a slight performance cost.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; result = mcb(example_data_path) # Run MCB on example dataset
(self = [0.08721123763355611, 0.17833660522736233, 0.18968222510423902, 0.2401197552240717, 0.14986851474968427, 0.2726565434395838, 0.2463076527192269, 0.21311734597718654, 0.12911296594333618, 0.33880929702119683  …  0.20493351356705938, 0.1315657625271143, 0.218615505877176, 0.1589526915862505, 0.11884772940321076, 0.16599279317487328, 0.09899721758865292, 0.20119392008973744, 0.2227777749890099, 0.14183390310488245],)

julia&gt; result_300 = mcb(example_data_path, threshold = 300); # Increase threshold length

julia&gt; length(result.self)
3801

julia&gt; length(result_300.self)
1650

julia&gt; mcb(example_data_path, altstart_codon_dict) # Use alternative start codons
(self = [0.08395614019755322, 0.17886564496310903, 0.1843882189861458, 0.2327059977332034, 0.14375956626276776, 0.26153451676836, 0.2277560915069008, 0.2084721025526067, 0.12748812450452368, 0.35284946520551547  …  0.19412496858111208, 0.15378185701040462, 0.22664543233169301, 0.1572460068164919, 0.12228357240597998, 0.16482459147152181, 0.09433344489896123, 0.2180785328818952, 0.22046000262742788, 0.14934890119286454],)

julia&gt; mcb(example_data_path, dataframe = true) # Get output in dataframe format
3801×3 DataFrame
  Row │ self       Identifier                         File                              
      │ Float64    String                             String                            
──────┼─────────────────────────────────────────────────────────────────────────────────
    1 │ 0.0872112  lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 0.178337   lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 0.189682   lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 0.24012    lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │     ⋮                      ⋮                                  ⋮
 3799 │ 0.201194   lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 0.222778   lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 0.141834   lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                       3794 rows omitted

julia&gt; all_genes = find_seqs(example_data_path, r&quot;&quot;); # Get a vector which is true for all genes

julia&gt; ribosomal_genes = find_seqs(example_data_path, r&quot;ribosomal&quot;); # Get a vector which is true for ribosomal genes

julia&gt; mcb(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,), dataframe = true) # Calculate MCB using ribosomal genes as a reference subset
3801×3 DataFrame
  Row │ ribosomal  Identifier                         File                              
      │ Float64    String                             String                            
──────┼─────────────────────────────────────────────────────────────────────────────────
    1 │ 0.142922   lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 0.179081   lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 0.306192   lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 0.296251   lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │     ⋮                      ⋮                                  ⋮
 3799 │ 0.239881   lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 0.260092   lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 0.197456   lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                       3794 rows omitted

julia&gt; mcb(example_data_path, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,), dataframe = true) # Calculate MCB using all genes and ribosomal genes as a reference subset
3801×4 DataFrame
  Row │ self       ribosomal  Identifier                         File                              
      │ Float64    Float64    String                             String                            
──────┼────────────────────────────────────────────────────────────────────────────────────────────
    1 │ 0.0872112  0.142922   lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 0.178337   0.179081   lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 0.189682   0.306192   lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 0.24012    0.296251   lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │     ⋮          ⋮                      ⋮                                  ⋮
 3799 │ 0.201194   0.239881   lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 0.222778   0.260092   lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 0.141834   0.197456   lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                                  3794 rows omitted

julia&gt; mcb(example_data_path, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,), dataframe = true) # Calculate MCB using all genes and ribosomal genes as a reference subset
3801×4 DataFrame
  Row │ self       ribosomal  Identifier                         File                              
      │ Float64    Float64    String                             String                            
──────┼────────────────────────────────────────────────────────────────────────────────────────────
    1 │ 0.0872112  0.142922   lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 0.178337   0.179081   lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 0.189682   0.306192   lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 0.24012    0.296251   lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │     ⋮          ⋮                      ⋮                                  ⋮
 3799 │ 0.201194   0.239881   lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 0.222778   0.260092   lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 0.141834   0.197456   lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                                  3794 rows omitted</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/CUB_measures.jl#L432-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.milc" href="#CUBScout.milc"><code>CUBScout.milc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">milc(filepath::String, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)
milc(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)</code></pre><p>Calculate MILC from Super and Vlahovicek, 2005.</p><p><strong>Arguments</strong></p><ul><li><code>filepath</code>: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it&#39;s assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>filepaths</code>: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). <code>CUBScout</code> is multithreaded; if there are multiple threads available, <code>CUBScout</code> will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it&#39;s never worth using more threads than the total number of files being analyzed. There are no quality checks, so it&#39;s assumed that each entry is an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>dict</code>: codon dictionary of type <code>codon_dict</code>. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using <code>make_codon_dict</code></li><li><code>ref_seqs</code>: by default, codon usage bias for each gene is calculated using the whole genome (&quot;self&quot;) as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, <code>ref_seqs</code> takes a named tuple in the form <code>(&quot;subset_name&quot; = Bool[],)</code>, where <code>Bool[]</code> is the same length as the number of sequences in your fasta file, and contains <code>true</code> for sequences you want as your reference subset and false for those you don&#39;t. You can use <code>find_seqs()</code> to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and <code>CUBScout</code> will return the calculated measure using each subset. If providing multiple filepaths and want custom reference sets, <code>ref_seqs</code> should be a vector of named tuples corresponding to the vector of filepaths.</li><li><code>rm_start</code>: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, <code>CUBScout</code> keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine&#39;s contribution to codon usage bias. If you set <code>rm_start</code> to <code>true</code>, the first codon of every sequence is simply discarded. This will also affect the gene&#39;s length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R&#39;s coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply <code>altstart_codon_dict</code> to the <code>dict</code> argument, and keep <code>rm_start</code> as <code>false</code>.</li><li><code>rm_stop</code>: whether to remove stop codons from calculations of codon usage bias.</li><li><code>threshold</code>: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set <code>threshold</code> to 0.</li><li><code>dataframe</code>: whether to format output as a dataframe. By default results are returned as vectors or named tuples (if the measure uses reference subsets). Setting <code>dataframe = true</code> will instead output a dataframe, though at a slight performance cost.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; result = milc(example_data_path) # Run MCB on example dataset
(self = [0.49482573202153163, 0.5839439121281993, 0.49947166558087047, 0.6354929447434434, 0.5439352548027006, 0.6104721251245075, 0.6256398806438782, 0.6228376952086359, 0.5355298113407091, 0.7832276821181443  …  0.5968814155010973, 0.5964500002803941, 0.5930680822246766, 0.5412999510428169, 0.49866919389111675, 0.5830959504630727, 0.5139438478694085, 0.6164434557282711, 0.6018041071661588, 0.48775477465069617],)

julia&gt; result_300 = milc(example_data_path, threshold = 300); # Increase threshold length

julia&gt; length(result.self)
3801

julia&gt; length(result_300.self)
1650

julia&gt; milc(example_data_path, altstart_codon_dict) # Use alternative start codons
(self = [0.49430677065204015, 0.5885230358759501, 0.5025039496927455, 0.6371410353128949, 0.5426521549091665, 0.6108102890984481, 0.6217053122088902, 0.6248550493920512, 0.5375433930570145, 0.822162494240932  …  0.5865793308679926, 0.6188550398687176, 0.5942360103321869, 0.5420673855853781, 0.5054979526357374, 0.5824007342085071, 0.5121161561615022, 0.6308328736610525, 0.6146790189624615, 0.5061508729549385],)

julia&gt; milc(example_data_path, dataframe = true) # Get output in dataframe format
3801×3 DataFrame
  Row │ self      Identifier                         File                              
      │ Float64   String                             String                            
──────┼────────────────────────────────────────────────────────────────────────────────
    1 │ 0.494826  lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 0.583944  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 0.499472  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 0.635493  lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │    ⋮                      ⋮                                  ⋮
 3799 │ 0.616443  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 0.601804  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 0.487755  lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                      3794 rows omitted


julia&gt; all_genes = find_seqs(example_data_path, r&quot;&quot;); # Get a vector which is true for all genes

julia&gt; ribosomal_genes = find_seqs(example_data_path, r&quot;ribosomal&quot;); # Get a vector which is true for ribosomal genes

julia&gt; milc(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,), dataframe = true) # Calculate MILC using ribosomal genes as a reference subset
3801×3 DataFrame
  Row │ ribosomal  Identifier                         File                              
      │ Float64    String                             String                            
──────┼─────────────────────────────────────────────────────────────────────────────────
    1 │  0.532406  lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │  0.579498  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │  0.541516  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │  0.668068  lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │     ⋮                      ⋮                                  ⋮
 3799 │  0.636678  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │  0.623519  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │  0.551733  lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                       3794 rows omitted

julia&gt; milc(example_data_path, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,), dataframe = true) # Calculate MILC using all genes and ribosomal genes as a reference subset
3801×4 DataFrame
  Row │ self      ribosomal  Identifier                         File                              
      │ Float64   Float64    String                             String                            
──────┼───────────────────────────────────────────────────────────────────────────────────────────
    1 │ 0.494826   0.532406  lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 0.583944   0.579498  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 0.499472   0.541516  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 0.635493   0.668068  lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │    ⋮          ⋮                      ⋮                                  ⋮
 3799 │ 0.616443   0.636678  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 0.601804   0.623519  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 0.487755   0.551733  lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                                 3794 rows omitted
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/CUB_measures.jl#L610-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.scuo" href="#CUBScout.scuo"><code>CUBScout.scuo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scuo(filepath::String, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)
scuo(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)</code></pre><p>Calculate SCUO from Wan et al., 2004. </p><p><strong>Arguments</strong></p><ul><li><code>filepath</code>: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it&#39;s assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>filepaths</code>: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). <code>CUBScout</code> is multithreaded; if there are multiple threads available, <code>CUBScout</code> will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it&#39;s never worth using more threads than the total number of files being analyzed. There are no quality checks, so it&#39;s assumed that each entry is an individual coding sequence, in the correct frame, without 5&#39; or 3&#39; untranslated regions.</li><li><code>dict</code>: codon dictionary of type <code>codon_dict</code>. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using <code>make_codon_dict</code></li><li><code>rm_start</code>: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, <code>CUBScout</code> keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine&#39;s contribution to codon usage bias. If you set <code>rm_start</code> to <code>true</code>, the first codon of every sequence is simply discarded. This will also affect the gene&#39;s length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R&#39;s coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply <code>altstart_codon_dict</code> to the <code>dict</code> argument, and keep <code>rm_start</code> as <code>false</code>.</li><li><code>rm_stop</code>: whether to remove stop codons from calculations of codon usage bias.</li><li><code>threshold</code>: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set <code>threshold</code> to 0.</li><li><code>dataframe</code>: whether to format output as a dataframe. By default results are returned as vectors or named tuples (if the measure uses reference subsets). Setting <code>dataframe = true</code> will instead output a dataframe, though at a slight performance cost.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; result = scuo(example_data_path) # Run SCUO on example dataset
3801-element Vector{Float64}:
 0.14312092935182216
 0.19123738759808445
 0.09632387849329298
 0.34521070127179804
 0.1057438762588421
 0.12037900551695478
 ⋮
 0.1545378175732701
 0.10969625791871884
 0.1840696872016822
 0.15616118648954513
 0.23591385815130636

julia&gt; result_300 = scuo(example_data_path, threshold = 300); # Increase threshold length

julia&gt; length(result)
3801

julia&gt; length(result_300)
1650

julia&gt; scuo(example_data_path, altstart_codon_dict) # Use alternative start codons
3801-element Vector{Float64}:
 0.14286111587263958
 0.19315278493814017
 0.0966128845976179
 0.3473543659821751
 0.10792236840320082
 0.12039525638448735
 ⋮
 0.152064610300728
 0.11200912387676948
 0.18952246579743504
 0.16473723774598686
 0.24160824180945173

julia&gt; scuo(example_data_path, dataframe = true) # Get output in dataframe format
3801×3 DataFrame
  Row │ SCUO       Identifier                         File                              
      │ Float64    String                             String                            
──────┼─────────────────────────────────────────────────────────────────────────────────
    1 │ 0.143121   lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…
    2 │ 0.191237   lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…
    3 │ 0.0963239  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…
    4 │ 0.345211   lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…
  ⋮   │     ⋮                      ⋮                                  ⋮
 3799 │ 0.18407    lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…
 3800 │ 0.156161   lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…
 3801 │ 0.235914   lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…
                                                                       3794 rows omitted
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/CUB_measures.jl#L767-L837">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.seq_descriptions-Tuple{AbstractString}" href="#CUBScout.seq_descriptions-Tuple{AbstractString}"><code>CUBScout.seq_descriptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seq_descriptions(path::AbstractString)</code></pre><p>Read a fasta file at <code>path</code> and return the <em>description</em> fields. Just adds convenience on top of FASTX functions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; seq_descr = seq_descriptions(example_data_path)
4237-element Vector{String}:
 &quot;lcl|NC_000964.3_cds_NP_387882.1&quot; ⋯ 430 bytes ⋯ &quot;ocation=410..1750] [gbkey=CDS]&quot;
 &quot;lcl|NC_000964.3_cds_NP_387883.1&quot; ⋯ 315 bytes ⋯ &quot;cation=1939..3075] [gbkey=CDS]&quot;
 &quot;lcl|NC_000964.3_cds_NP_387884.1&quot; ⋯ 305 bytes ⋯ &quot;cation=3206..3421] [gbkey=CDS]&quot;
 &quot;lcl|NC_000964.3_cds_NP_387885.1&quot; ⋯ 350 bytes ⋯ &quot;cation=3437..4549] [gbkey=CDS]&quot;
 &quot;lcl|NC_000964.3_cds_NP_387886.2&quot; ⋯ 248 bytes ⋯ &quot;cation=4567..4812] [gbkey=CDS]&quot;
 &quot;lcl|NC_000964.3_cds_NP_387887.1&quot; ⋯ 466 bytes ⋯ &quot;cation=4867..6783] [gbkey=CDS]&quot;
 ⋮
 &quot;lcl|NC_000964.3_cds_NP_391982.1&quot; ⋯ 428 bytes ⋯ &quot;4211510..4212889)] [gbkey=CDS]&quot;
 &quot;lcl|NC_000964.3_cds_NP_391983.1&quot; ⋯ 375 bytes ⋯ &quot;4213200..4213826)] [gbkey=CDS]&quot;
 &quot;lcl|NC_000964.3_cds_NP_391984.1&quot; ⋯ 351 bytes ⋯ &quot;4213823..4214608)] [gbkey=CDS]&quot;
 &quot;lcl|NC_000964.3_cds_NP_391985.1&quot; ⋯ 381 bytes ⋯ &quot;4214753..4215103)] [gbkey=CDS]&quot;
 &quot;lcl|NC_000964.3_cds_NP_391986.1&quot; ⋯ 313 bytes ⋯ &quot;4215255..4215389)] [gbkey=CDS]&quot;

julia&gt; seq_descr[1]
&quot;lcl|NC_000964.3_cds_NP_387882.1_1 [gene=dnaA] [locus_tag=BSU_00010] [db_xref=EnsemblGenomes-Gn:BSU00010,EnsemblGenomes-Tr:CAB11777,GOA:P05648,InterPro:IPR001957,InterPro:IPR003593,InterPro:IPR010921,InterPro:IPR013159,InterPro:IPR013317,InterPro:IPR018312,InterPro:IPR020591,InterPro:IPR024633,InterPro:IPR027417,PDB:4TPS,SubtiList:BG10065,UniProtKB/Swiss-Prot:P05648] [protein=chromosomal replication initiator informational ATPase] [protein_id=NP_387882.1] [location=410..1750] [gbkey=CDS]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/accessory_functions.jl#L222-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUBScout.seq_names-Tuple{AbstractString}" href="#CUBScout.seq_names-Tuple{AbstractString}"><code>CUBScout.seq_names</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seq_names(path::AbstractString)</code></pre><p>Read a fasta file at <code>path</code> and return the <em>name</em> fields. Just adds convenience on top of FASTX functions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; seq_names(example_data_path)
4237-element Vector{String}:
 &quot;lcl|NC_000964.3_cds_NP_387882.1_1&quot;
 &quot;lcl|NC_000964.3_cds_NP_387883.1_2&quot;
 &quot;lcl|NC_000964.3_cds_NP_387884.1_3&quot;
 &quot;lcl|NC_000964.3_cds_NP_387885.1_4&quot;
 &quot;lcl|NC_000964.3_cds_NP_387886.2_5&quot;
 &quot;lcl|NC_000964.3_cds_NP_387887.1_6&quot;
 ⋮
 &quot;lcl|NC_000964.3_cds_NP_391982.1_4233&quot;
 &quot;lcl|NC_000964.3_cds_NP_391983.1_4234&quot;
 &quot;lcl|NC_000964.3_cds_NP_391984.1_4235&quot;
 &quot;lcl|NC_000964.3_cds_NP_391985.1_4236&quot;
 &quot;lcl|NC_000964.3_cds_NP_391986.1_4237&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gus-pendleton/CUBScout.jl/blob/d1193ec5a5c93ba2cad954553a5704218a4532e5/src/accessory_functions.jl#L190-L211">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 31 May 2023 12:35">Wednesday 31 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
