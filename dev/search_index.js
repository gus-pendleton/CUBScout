var documenterSearchIndex = {"docs":
[{"location":"functions/#Index-of-Functions","page":"Functions","title":"Index of Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [CUBScout]","category":"page"},{"location":"functions/#CUBScout.example_data_path","page":"Functions","title":"CUBScout.example_data_path","text":"example_data_path\n\nThe path to an example dataset, stored as an artifact within the package. This is an .fna file containing coding sequences from Bacillus subtilis subsp. subtilis str. 168, NCBI Accession # NC_000964.3.\n\n\n\n\n\n","category":"constant"},{"location":"functions/#CUBScout.codon_dict","page":"Functions","title":"CUBScout.codon_dict","text":"codon_dict\n\nThe codon_dict type defines how codons are translated, and is essential for calculating codon usage bias as it identifies stop codons and each amino acid's degeneracy. A default codon dictionary is provided (default_codon_dict), or a user can make their own using the make_codon_dict function.\n\nFields\n\ncodons: the 64 codons, in alphabetical order\nAA: corresponding amino acid for each codon (64 entries long)\nAA_nostops: same as AA, but with stop codons removed\nuniqueAA: unique amino acid names including stop codons. Under a standard translation table, this is 21 amino acids long\nuniqueAA: same as uniqueAA, but with stop codons removed\nuniqueI: a vector of the same length as uniqueAA, containing vectors of the indices of each codon for that amino acid. For instance, the first entry corresponds to Lysine, and contains the vector [1, 3], corresponding to the positions of codons AAA and AAG in the codons field\nuniqueI_nostops: same as uniqueI, but with stop codons removed\ndeg: a vector of the same length as uniqueAA, containing the degeneracy for each amino acid.\ndeg_nostops: same as deg, but with stop codons removed\nstop_mask: a Boolean vector of length 64 which is false for stop codons. This is used to remove stop codons when calculating codon usage bias.\n\nNotes\n\nGenerally, CUBScout users shouldn't need to interact with the codon_dict type, as the standard genetic code is applied by default. Details for constructing a custom codon_dict are documented under the make_codon_dict function.\n\n\n\n\n\n","category":"type"},{"location":"functions/#CUBScout.all_cub","page":"Functions","title":"CUBScout.all_cub","text":"all_cub(filepath::String, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\nall_cub(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate all codon usage bias measures at once. Because many measures require the same initial calculations, this is more efficient than calculating them individually.\n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nref_seqs: by default, codon usage bias for each gene is calculated using the whole genome (\"self\") as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, ref_seqs takes a named tuple in the form (\"subset_name\" = Bool[],), where Bool[] is the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and CUBScout will return the calculated measure using each subset. If providing multiple filepaths and want custom reference sets, ref_seqs should be a vector of named tuples corresponding to the vector of filepaths.\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as named tuples. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> all_cub_results = all_cub(example_data_path); # Calculate all six codon usage measures on example dataset\n\njulia> all_cub(example_data_path, dataframe = true); # Get output in dataframe format\n\njulia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> all_cub(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,), dataframe = true); # Calculate all measures using ribosomal genes as a reference subset\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.b","page":"Functions","title":"CUBScout.b","text":"b(filepath::String, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\nb(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate B from Karlin and Mrazek, 1996. \n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nref_seqs: by default, codon usage bias for each gene is calculated using the whole genome (\"self\") as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, ref_seqs takes a named tuple in the form (\"subset_name\" = Bool[],), where Bool[] is the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and CUBScout will return the calculated measure using each subset. If providing multiple filepaths and want custom reference sets, ref_seqs should be a vector of named tuples corresponding to the vector of filepaths.\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as named tuples. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> result = b(example_data_path); # Calculate measure on example dataset\n\njulia> result_300 = b(example_data_path, threshold = 300); # Increase threshold length\n\njulia> length(result.self)\n3801\n\njulia> length(result_300.self)\n1650\n\njulia> round.(result.self[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.209127\n 0.328976\n 0.223653\n 0.539114\n 0.249196\n\njulia> b(example_data_path, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> b(example_data_path, rm_start = true); # Remove start codons\n\njulia> b(example_data_path, dataframe = true); # Get output in dataframe format\n\njulia> all_genes = find_seqs(example_data_path, r\"\"); # Get a vector which is true for all genes\n\njulia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> b(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,), dataframe = true); # Calculate using ribosomal genes as a reference subset\n\njulia> b(example_data_path, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,), dataframe = true); # Calculate using all genes and ribosomal genes as a reference subset\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.cai","page":"Functions","title":"CUBScout.cai","text":"cai(filepath::String, ref_vector::Vector{Bool}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\ncai(filepaths::Vector{String}, ref_vectors::Vector{Vector{Bool}}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate CAI from Sharp and Lee, 1987.\n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nref_vector: reference subset, which is required for cai. Bool[] the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. If providing multiple filepaths and want custom reference sets, ref_vectors should be a vector of vectors corresponding to the vector of filepaths.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as vectors. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> result = cai(example_data_path, ribosomal_genes); # Calculate CAI on example dataset\n\njulia> round.(result.CAI[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.844967\n 0.88548\n 0.817348\n 1.072675\n 0.834179\n\njulia> cai(example_data_path, ribosomal_genes, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> cai(example_data_path, ribosomal_genes, rm_start = true); # Remove start codons\n\njulia> cai(example_data_path, ribosomal_genes, dataframe = true); # Get output in dataframe format\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.e","page":"Functions","title":"CUBScout.e","text":"e(filepath::String, ref_vector::Vector{Bool}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\ne(filepaths::Vector{String}, ref_vectors::Vector{Vector{Bool}}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate E from Karlin and Mrazek, 1996.\n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nref_vector: reference subset, which is required for e. Bool[] the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. If providing multiple filepaths and want custom reference sets, ref_vectors should be a vector of vectors corresponding to the vector of filepaths.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as vectors. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> result = e(example_data_path, ribosomal_genes); # Calculate E on example dataset\n\njulia> round.(result.E[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.762317\n 1.025839\n 0.875954\n 0.986498\n 1.111275\n\njulia> e(example_data_path, ribosomal_genes, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> e(example_data_path, ribosomal_genes, rm_start = true); # Remove start codons\n\njulia> e(example_data_path, ribosomal_genes, dataframe = true); # Get output in dataframe format\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.enc","page":"Functions","title":"CUBScout.enc","text":"enc(filepath::String, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\nenc(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate ENC from Wright, 1990. \n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as named tuples. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> result = enc(example_data_path); # Run ENC on example dataset\n\njulia> round.(result.ENC[1:5], digits = 6)\n5-element Vector{Float64}:\n 56.787282\n 52.725947\n 59.287949\n 52.296686\n 55.262981\n\njulia> result_300 = enc(example_data_path, threshold = 300); # Increase threshold length\n\njulia> length(result.ENC)\n3801\n\njulia> length(result_300.ENC)\n1650\n\njulia> enc(example_data_path, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> enc(example_data_path, rm_start = true); # Remove start codons\n\njulia> enc(example_data_path, dataframe = true); # Get output in dataframe format\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.enc_p","page":"Functions","title":"CUBScout.enc_p","text":"enc_p(filepath::String, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\nenc_p(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate ENC' from Novembre, 2002.\n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nref_seqs: by default, codon usage bias for each gene is calculated using the whole genome (\"self\") as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, ref_seqs takes a named tuple in the form (\"subset_name\" = Bool[],), where Bool[] is the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and CUBScout will return the calculated measure using each subset. If providing multiple filepaths and want custom reference sets, ref_seqs should be a vector of named tuples corresponding to the vector of filepaths.\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as named tuples. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> result = enc_p(example_data_path); # Calculate measure on example dataset\n\njulia> result_300 = enc_p(example_data_path, threshold = 300); # Increase threshold length\n\njulia> length(result.self)\n3801\n\njulia> length(result_300.self)\n1650\n\njulia> round.(result.self[1:5], digits = 6)\n5-element Vector{Float64}:\n 61.0\n 59.369798\n 60.749462\n 61.0\n 61.0\n\njulia> enc_p(example_data_path, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> enc_p(example_data_path, rm_start = true); # Remove start codons\n\njulia> enc_p(example_data_path, dataframe = true); # Get output in dataframe format\n\njulia> all_genes = find_seqs(example_data_path, r\"\"); # Get a vector which is true for all genes\n\njulia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> enc_p(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,), dataframe = true); # Calculate using ribosomal genes as a reference subset\n\njulia> enc_p(example_data_path, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,), dataframe = true); # Calculate using all genes and ribosomal genes as a reference subset\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.find_seqs-Tuple{AbstractString, Regex}","page":"Functions","title":"CUBScout.find_seqs","text":"find_seqs(path::AbstractString, match_pattern::Regex)\n\nRead a fasta file at path and query the description field for a given Regex match_pattern. These results can be supplied in either the reference tuples (for codon usage bias functions) or reference vectors (for expressivity measures).\n\nExamples\n\njldoctest julia> find_seqs(example_data_path, r\"ribosomal\")[1:5] 5-element Vector{Bool}:  0  0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"functions/#CUBScout.fop","page":"Functions","title":"CUBScout.fop","text":"fop(filepath::String, ref_vector::Vector{Bool}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\nfop(filepaths::Vector{String}, ref_vectors::Vector{Vector{Bool}}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate FOP from Ikemura, 1981.\n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nref_vector: reference subset, which is required for fop. Bool[] the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. If providing multiple filepaths and want custom reference sets, ref_vectors should be a vector of vectors corresponding to the vector of filepaths.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as vectors. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> result = fop(example_data_path, ribosomal_genes); # Calculate CAI on example dataset\n\njulia> round.(result.FOP[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.567816\n 0.566845\n 0.509695\n 0.725\n 0.653784\n\njulia> fop(example_data_path, ribosomal_genes, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> fop(example_data_path, ribosomal_genes, rm_start = true); # Remove start codons\n\njulia> fop(example_data_path, ribosomal_genes, dataframe = true); # Get output in dataframe format\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.gcb","page":"Functions","title":"CUBScout.gcb","text":"gcb(filepath::String, dict::codon_dict = default_codon_dict; ref_vector = [], perc = 0.05, rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\ngcb(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_vector = [], perc = 0.05, rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate GCB from Merkl, 2003.\n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nref_vector: optional reference subset; by default gcb begins calculations using all genes as a seed. If you want to provide a custom reference set, it should be a vector Bool[] the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. If providing multiple filepaths and want custom reference sets, ref_vectors should be a vector of vectors corresponding to the vector of filepaths.\nperc: percentage of \"top hits\" which should be used as a reference set in the next iteration. By default set to 0.05. \nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as vectors. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> result = gcb(example_data_path); # Calculate GCB on example dataset\n\njulia> round.(result.GCB[1:5], digits = 6)\n5-element Vector{Float64}:\n -0.058765\n -0.08659\n -0.005496\n -0.065659\n -0.032062\n\njulia> ribo_result = gcb(example_data_path, ref_vector = ribosomal_genes); # Calculate GCB with ribosomal genes as reference seed example dataset\n\njulia> round.(ribo_result.GCB[1:5], digits = 6)\n5-element Vector{Float64}:\n -0.135615\n -0.036687\n -0.169136\n -0.186104\n -0.01653\n\njulia> fop(example_data_path, ribosomal_genes, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> fop(example_data_path, ribosomal_genes, rm_start = true); # Remove start codons\n\njulia> fop(example_data_path, ribosomal_genes, dataframe = true); # Get output in dataframe format\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.make_codon_dict","page":"Functions","title":"CUBScout.make_codon_dict","text":"make_codon_dict(filepath::AbstractString, delimiter::AbstractChar = '\t')\n\nMake a custom codon dictionary for organisms with non-standard genetic code. filepath points to a delimited file with two columns and no header. The first column should be codons, and the second column their corresponding amino acid. Avoid spaces and special characters (e.g., write GlutamicAcid instead of Glutamic Acid). Stop codons can be coded as Stop, stop, STOP, or *. If delimited using any character outside of tab, supply the delimiter as the second argument as Char, not a string (e.g. ',' not \",\"). make_codon_dict uses readdlm from DelimitedFiles; it's a good idea to check whether readdlm parses your file correctly before passing to make_codon_dict\n\nExamples\n\njulia> my_codon_dict = make_codon_dict(CUBScout.codon_dict_path)\ncodon_dict(BioSequences.LongSequence{BioSequences.DNAAlphabet{2}}[AAA, AAC, AAG, AAT, ACA, ACC, ACG, ACT, AGA, AGC  …  TCG, TCT, TGA, TGC, TGG, TGT, TTA, TTC, TTG, TTT], [\"Lysine\", \"Asparagine\", \"Lysine\", \"Asparagine\", \"Threonine\", \"Threonine\", \"Threonine\", \"Threonine\", \"Arginine\", \"Serine\"  …  \"Serine\", \"Serine\", \"Stop\", \"Cysteine\", \"Tryptophan\", \"Cysteine\", \"Leucine\", \"Phenylalanine\", \"Leucine\", \"Phenylalanine\"], [\"Lysine\", \"Asparagine\", \"Lysine\", \"Asparagine\", \"Threonine\", \"Threonine\", \"Threonine\", \"Threonine\", \"Arginine\", \"Serine\"  …  \"Serine\", \"Serine\", \"Serine\", \"Cysteine\", \"Tryptophan\", \"Cysteine\", \"Leucine\", \"Phenylalanine\", \"Leucine\", \"Phenylalanine\"], [\"Lysine\", \"Asparagine\", \"Threonine\", \"Arginine\", \"Serine\", \"Isoleucine\", \"Methionine\", \"Glutamine\", \"Histidine\", \"Proline\"  …  \"Glutamicacid\", \"Asparticacid\", \"Alanine\", \"Glycine\", \"Valine\", \"Stop\", \"Tyrosine\", \"Cysteine\", \"Tryptophan\", \"Phenylalanine\"], [\"Lysine\", \"Asparagine\", \"Threonine\", \"Arginine\", \"Serine\", \"Isoleucine\", \"Methionine\", \"Glutamine\", \"Histidine\", \"Proline\", \"Leucine\", \"Glutamicacid\", \"Asparticacid\", \"Alanine\", \"Glycine\", \"Valine\", \"Tyrosine\", \"Cysteine\", \"Tryptophan\", \"Phenylalanine\"], Vector{Int32}[[1, 3], [2, 4], [5, 6, 7, 8], [9, 11, 25, 26, 27, 28], [10, 12, 53, 54, 55, 56], [13, 14, 16], [15], [17, 19], [18, 20], [21, 22, 23, 24]  …  [33, 35], [34, 36], [37, 38, 39, 40], [41, 42, 43, 44], [45, 46, 47, 48], [49, 51, 57], [50, 52], [58, 60], [59], [62, 64]], Vector{Int32}[[1, 3], [2, 4], [5, 6, 7, 8], [9, 11, 25, 26, 27, 28], [10, 12, 51, 52, 53, 54], [13, 14, 16], [15], [17, 19], [18, 20], [21, 22, 23, 24], [29, 30, 31, 32, 58, 60], [33, 35], [34, 36], [37, 38, 39, 40], [41, 42, 43, 44], [45, 46, 47, 48], [49, 50], [55, 57], [56], [59, 61]], Int32[2, 2, 4, 6, 6, 3, 1, 2, 2, 4  …  2, 2, 4, 4, 4, 3, 2, 2, 1, 2], Int32[2, 2, 4, 6, 6, 3, 1, 2, 2, 4, 6, 2, 2, 4, 4, 4, 2, 2, 1, 2], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  1, 1, 0, 1, 1, 1, 1, 1, 1, 1])\n\njulia> typeof(my_codon_dict)\ncodon_dict\n\njulia> fieldnames(codon_dict)\n(:codons, :AA, :AA_nostops, :uniqueAA, :uniqueAA_nostops, :uniqueI, :uniqueI_nostops, :deg, :deg_nostops, :stop_mask)\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.mcb","page":"Functions","title":"CUBScout.mcb","text":"mcb(filepath::String, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\nmcb(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate MCB from Urutia and Hurst, 2001.\n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nref_seqs: by default, codon usage bias for each gene is calculated using the whole genome (\"self\") as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, ref_seqs takes a named tuple in the form (\"subset_name\" = Bool[],), where Bool[] is the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and CUBScout will return the calculated measure using each subset. If providing multiple filepaths and want custom reference sets, ref_seqs should be a vector of named tuples corresponding to the vector of filepaths.\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as named tuples. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> result = mcb(example_data_path); # Calculate measure on example dataset\n\njulia> result_300 = mcb(example_data_path, threshold = 300); # Increase threshold length\n\njulia> length(result.self)\n3801\n\njulia> length(result_300.self)\n1650\n\njulia> round.(result.self[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.087211\n 0.178337\n 0.189682\n 0.24012\n 0.149869\n\njulia> mcb(example_data_path, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> mcb(example_data_path, rm_start = true); # Remove start codons\n\njulia> mcb(example_data_path, dataframe = true); # Get output in dataframe format\n\njulia> all_genes = find_seqs(example_data_path, r\"\"); # Get a vector which is true for all genes\n\njulia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> mcb(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,), dataframe = true); # Calculate using ribosomal genes as a reference subset\n\njulia> mcb(example_data_path, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,), dataframe = true); # Calculate using all genes and ribosomal genes as a reference subset\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.melp","page":"Functions","title":"CUBScout.melp","text":"melp(filepath::String, ref_vector::Vector{Bool}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\nmelp(filepaths::Vector{String}, ref_vectors::Vector{Vector{Bool}}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate MELP from Supek and Vlahovicek, 2005.\n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nref_vector: reference subset, which is required for melp. Bool[] the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. If providing multiple filepaths and want custom reference sets, ref_vectors should be a vector of vectors corresponding to the vector of filepaths.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as vectors. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> result = melp(example_data_path, ribosomal_genes); # Calculate MELP on example dataset\n\njulia> round.(result.MELP[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.929414\n 1.007671\n 0.922357\n 0.951239\n 1.029531\n\njulia> melp(example_data_path, ribosomal_genes, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> melp(example_data_path, ribosomal_genes, rm_start = true); # Remove start codons\n\njulia> melp(example_data_path, ribosomal_genes, dataframe = true); # Get output in dataframe format\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.milc","page":"Functions","title":"CUBScout.milc","text":"milc(filepath::String, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\nmilc(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate MILC from Supek and Vlahovicek, 2005.\n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nref_seqs: by default, codon usage bias for each gene is calculated using the whole genome (\"self\") as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, ref_seqs takes a named tuple in the form (\"subset_name\" = Bool[],), where Bool[] is the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and CUBScout will return the calculated measure using each subset. If providing multiple filepaths and want custom reference sets, ref_seqs should be a vector of named tuples corresponding to the vector of filepaths.\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as named tuples. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> result = milc(example_data_path); # Calculate measure on example dataset\n\njulia> result_300 = milc(example_data_path, threshold = 300); # Increase threshold length\n\njulia> length(result.self)\n3801\n\njulia> length(result_300.self)\n1650\n\njulia> round.(result.self[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.494826\n 0.583944\n 0.499472\n 0.635493\n 0.543935\n\njulia> milc(example_data_path, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> milc(example_data_path, rm_start = true); # Remove start codons\n\njulia> milc(example_data_path, dataframe = true); # Get output in dataframe format\n\njulia> all_genes = find_seqs(example_data_path, r\"\"); # Get a vector which is true for all genes\n\njulia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> milc(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,), dataframe = true); # Calculate using ribosomal genes as a reference subset\n\njulia> milc(example_data_path, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,), dataframe = true); # Calculate using all genes and ribosomal genes as a reference subset\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.scuo","page":"Functions","title":"CUBScout.scuo","text":"scuo(filepath::String, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\nscuo(filepaths::Vector{String}, dict::codon_dict = default_codon_dict; rm_start = false, rm_stop = false, threshold = 80, dataframe = false)\n\nCalculate SCUO from Wan et al., 2004. \n\nArguments\n\nfilepath: path to fasta file of coding sequences (e.g. .fasta, .fna, .fa). There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\nfilepaths: vector of paths to fasta files of coding sequences (e.g. .fasta, .fna, .fa). CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of paths as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed. There are no quality checks, so it's assumed that each entry is an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions.\ndict: codon dictionary of type codon_dict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_codon_dict\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply altstart_codon_dict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\ndataframe: whether to format output as a dataframe. By default results are returned as named tuples. Setting dataframe = true will instead output a dataframe, though at a slight performance cost.\n\nExamples\n\njulia> result = scuo(example_data_path); # Run SCUO on example dataset\n\njulia> round.(result.SCUO[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.143121\n 0.191237\n 0.096324\n 0.345211\n 0.105744\n\njulia> result_300 = scuo(example_data_path, threshold = 300); # Increase threshold length\n\njulia> length(result.SCUO)\n3801\n\njulia> length(result_300.SCUO)\n1650\n\njulia> scuo(example_data_path, altstart_codon_dict); # Code TTG and CTG as methionine\n\njulia> scuo(example_data_path, rm_start = true); # Remove start codons\n\njulia> scuo(example_data_path, dataframe = true); # Get output in dataframe format\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.seq_descriptions-Tuple{AbstractString}","page":"Functions","title":"CUBScout.seq_descriptions","text":"seq_descriptions(path::AbstractString)\n\nRead a fasta file at path and return the description fields. Just adds convenience on top of FASTX functions.\n\nExamples\n\njulia> seq_descr = seq_descriptions(example_data_path);\n\njulia> seq_descr[1]\n\"lcl|NC_000964.3_cds_NP_387882.1_1 [gene=dnaA] [locus_tag=BSU_00010] [db_xref=EnsemblGenomes-Gn:BSU00010,EnsemblGenomes-Tr:CAB11777,GOA:P05648,InterPro:IPR001957,InterPro:IPR003593,InterPro:IPR010921,InterPro:IPR013159,InterPro:IPR013317,InterPro:IPR018312,InterPro:IPR020591,InterPro:IPR024633,InterPro:IPR027417,PDB:4TPS,SubtiList:BG10065,UniProtKB/Swiss-Prot:P05648] [protein=chromosomal replication initiator informational ATPase] [protein_id=NP_387882.1] [location=410..1750] [gbkey=CDS]\"\n\n\n\n\n\n","category":"method"},{"location":"functions/#CUBScout.seq_names-Tuple{AbstractString}","page":"Functions","title":"CUBScout.seq_names","text":"seq_names(path::AbstractString)\n\nRead a fasta file at path and return the name fields. Just adds convenience on top of FASTX functions.\n\nExamples\n\njulia> seq_name_vector = seq_names(example_data_path);\n\njulia> seq_name_vector[1]\n\"lcl|NC_000964.3_cds_NP_387882.1_1\"\n\n\n\n\n\n","category":"method"},{"location":"cub/#Calculating-Codon-Usage-Bias","page":"Codon Usage Bias","title":"Calculating Codon Usage Bias","text":"","category":"section"},{"location":"cub/#Under-default-parameters","page":"Codon Usage Bias","title":"Under default parameters","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Codon usage bias can be calculated using the functions b(), enc(), enc_p(), mcb(), milc() and scuo(). At their simplest, these functions accept a string which is the filepath to a fasta-formatted file of coding sequences. The output is a vector giving the codon usage bias of each coding sequence in the fasta file. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"warning: Warning\nCUBScout does not identify ORFs, pause at stop codons, or parse non-nucleotide characters. It is assumed the coding sequences you provide are in-frame and don't contain 5' or 3' untranslated regions. Codons which have non-specific nucleotides, like \"W\", are skipped. Sequences with characters outside of those recognized by BioSequences will throw an error.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"CUBScout is loaded with an example dataset, which can accessed at CUBScout.example_data_path. This string points to a .fna of coding sequences from B. subtilis. Let's calculate ENC for the genes in this file. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> example_data_path\n\"/your/path/to/file/B_subtilis.fna\"\n\njulia> enc_result = enc(example_data_path);\n\njulia> enc_result.ENC\n3801-element Vector{Float64}:\n 56.787282202547104\n 52.725946690067296\n 59.287948966886226\n 52.29668642771212\n 55.26298060679466\n 53.44161579771853\n  ⋮\n 50.30390962534221\n 56.29539618087172\n 55.229391962859935\n 52.58401385627267\n 60.19275631834157\n\njulia> enc_result.Identifier\n3801-element Vector{String}:\n \"lcl|NC_000964.3_cds_NP_387882.1_1\"\n \"lcl|NC_000964.3_cds_NP_387883.1_2\"\n \"lcl|NC_000964.3_cds_NP_387885.1_4\"\n \"lcl|NC_000964.3_cds_NP_387886.2_5\"\n \"lcl|NC_000964.3_cds_NP_387887.1_6\"\n \"lcl|NC_000964.3_cds_NP_387888.1_7\"\n ⋮\n \"lcl|NC_000964.3_cds_NP_391981.1_4232\"\n \"lcl|NC_000964.3_cds_NP_391982.1_4233\"\n \"lcl|NC_000964.3_cds_NP_391983.1_4234\"\n \"lcl|NC_000964.3_cds_NP_391984.1_4235\"\n \"lcl|NC_000964.3_cds_NP_391985.1_4236\"","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"ENC and SCUO calculate codon usage bias against a theoretical, unbiased distribution, and so simply return a named tuple containing ENC/SCUO and then the gene identifiers. B, ENC', MCB, and MILC calculate an expected codon frequency using a reference set of the genome, and then calculate codon usage bias for each gene against that reference set. As such, these functions return a named tuple which describes which reference set was used, alongside gene identifiers. By default, the codon usage bias is calculated against the codon usage bias of the genome as a whole, which we typically refer to as \"self\".","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> b_result = b(example_data_path)\n(self = [0.20912699220973896, 0.3289759448740455, 0.22365336363593893, 0.5391135258658497, 0.24919594143501034, 0.2880358413249049, 0.31200964304415874, 0.34858035204347476, 0.2455189361074733, 0.4690734561271221  …  0.3629137353834403, 0.3621330537227321, 0.4535285720373026, 0.3357858047622507, 0.28183191395624935, 0.2668809561422238, 0.22381338105820905, 0.4034837015709619, 0.3594626865160133, 0.3724863965444541],)\n\njulia> b_result.self\n3801-element Vector{Float64}:\n 0.20912699220973896\n 0.3289759448740455\n 0.22365336363593893\n 0.5391135258658497\n 0.24919594143501034\n 0.2880358413249049\n ⋮\n 0.2668809561422238\n 0.22381338105820905\n 0.4034837015709619\n 0.3594626865160133\n 0.3724863965444541","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Many of these measures rely on the same initial calculations. If you want to calculate all six measures at the same time, use the function all_cub(). This only runs these initial calculations once before calculating individual codon usage measures, and as such is more efficient than running all the functions separately. By default, all_cub returns a named tuple, each key of which corresponds to a different codon usage bias measure.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> all_cub_result = all_cub(example_data_path);\n\njulia> all_cub_result.B.self\n3801-element Vector{Float64}:\n 0.20912699220973896\n 0.3289759448740455\n 0.22365336363593893\n 0.5391135258658497\n 0.24919594143501034\n 0.2880358413249049\n ⋮\n 0.2668809561422238\n 0.22381338105820905\n 0.4034837015709619\n 0.3594626865160133\n 0.3724863965444541\n\njulia> all_cub_result.ENC.ENC\n3801-element Vector{Float64}:\n 56.787282202547104\n 52.725946690067296\n 59.287948966886226\n 52.29668642771212\n 55.26298060679466\n 53.44161579771853\n  ⋮\n 50.30390962534221\n 56.29539618087172\n 55.229391962859935\n 52.58401385627267\n 60.19275631834157","category":"page"},{"location":"cub/#Codon-Dictionaries","page":"Codon Usage Bias","title":"Codon Dictionaries","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"If you are working with genomes that use the standard genetic code, than feel free to skip this section - you should not need to worry about it. By default, CUBScout translates sequences using the standard code, as loaded in CUBScout.default_codon_dict. However, if your sequences are translated differently, you will need to provide a custom codon dictionary to CUBScout. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Codon dictionaries are of a custom type codon_dict. You can use ?codon_dict to see the information this struct holds, which our codon usage bias functions need to correctly translate codons and calculate codon frequency. However, I recommend you do not construct a codon_dict manually, but instead make one using the make_codon_dict() function. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"make_codon_dict reads a plain text delimited file which lists the 64 codons and their corresponding amino acid. The file should look something like this:","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"AAA    Lysine\nAAC    Asparagine\nAAG    Lysine \n...    ...","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Please follow these formatting guidelines to make sure the table is parsed correctly:","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"The first column should be codons, and the second column their corresponding amino acid. \nDo not include headers and avoid trailing whitespace. \nCodons do not need to be alphabetized. \nAvoid spaces and special characters (e.g., write GlutamicAcid instead of Glutamic Acid). \nStop codons can be coded as Stop, stop, STOP, or *. \nIf delimited using any character outside of tab, supply the delimiter as the second argument as a Char, not a String (e.g. ',' not \",\"). ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"make_codon_dict uses readdlm from DelimitedFiles; it's a good idea to check whether readdlm parses your file correctly before passing to make_codon_dict.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"For demonstration purposes, CUBScout includes the delimited file used to construct the default_codon_dict. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> codon_dict_path\n\"your/path/to/codon_dict.txt\"\n\njulia> our_codon_dict = make_codon_dict(codon_dict_path);\n\njulia> our_codon_dict.codons\n64-element Vector{BioSequences.LongSequence{BioSequences.DNAAlphabet{2}}}:\n AAA\n AAC\n AAG\n AAT\n[...]\n\njulia> our_codon_dict.AA\n64-element Vector{String}:\n \"Lysine\"\n \"Asparagine\"\n \"Lysine\"\n \"Asparagine\"\n [...]","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"You can supply your custom codon dictionary to any of the codon usage bias functions as the second argument.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> milc(example_data_path, our_codon_dict)\n(self = [0.49482573202153163, 0.5839439121281993, 0.49947166558087047, 0.6354929447434434, 0.5439352548027006, 0.6104721251245075, 0.6256398806438782, 0.6228376952086359, 0.5355298113407091, 0.7832276821181443  …  0.5968814155010973, 0.5964500002803941, 0.5930680822246766, 0.5412999510428169, 0.49866919389111675, 0.5830959504630727, 0.5139438478694085, 0.6164434557282711, 0.6018041071661588, 0.48775477465069617],)","category":"page"},{"location":"cub/#Alternative-Start-Codons","page":"Codon Usage Bias","title":"Alternative Start Codons","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"CUBScout provides three options to handle start codons outside of ATG. By default, alternative codons are translated as they would be anywhere else in the sequence. As such, TTG would be counted as leucine, even when in the first position.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"If you would like to disregard start codons entirely, set the argument rm_start = true. This will decrease the length of each gene sequence by one, but is my preferred method to dealing with alternative start codons.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Other packages to calculate codon usage bias, such as coRdon, handle alternative start codons differently. They encode all TTG and CTG codons as methionine, regardless of their location in the gene. While I disagree with this approach from a biological perspective, you can implement it using the pre-loaded altstart_codon_dict. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> scuo_result = scuo(example_data_path, altstart_codon_dict);\n\njulia> scuo_result.SCUO\n3801-element Vector{Float64}:\n 0.14286111587263958\n 0.19315278493814017\n 0.0966128845976179\n 0.3473543659821751\n 0.10792236840320082\n 0.12039525638448735\n ⋮\n 0.152064610300728\n 0.11200912387676948\n 0.18952246579743504\n 0.16473723774598686\n 0.24160824180945173","category":"page"},{"location":"cub/#Custom-Reference-Sets-with-ref_seqs","page":"Codon Usage Bias","title":"Custom Reference Sets with ref_seqs","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"B, ENC', MCB, and MILC all calculate an expected codon frequency using a reference set of the genome, and then calculate codon usage bias for each gene against that reference set. By default, this is the entire genome (\"self\"). However, you can provide your own reference subset(s) to these functions. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"First, you'll need a Boolean vector, whose length matches the number of sequences in your fasta file. Genes which you want included in your subset should be true; the rest of the vector should be false. One way to make this vector is with the find_seqs function to look for genes with specific functions.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> ribosomal_genes = find_seqs(example_data_path, r\"ribosomal\")\n4237-element Vector{Bool}:\n 0\n 0\n 0\n 0\n 0\n 0\n ⋮\n 0\n 0\n 0\n 0\n 1","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"tip: Tip\nCUBScout is designed not to hold the data from your fasta file as an object in your Julia environment. If you want to get sequence identifiers or descriptions outside of codon usage bias functions, there are the convenience functions seq_names and seq_descriptions:julia> seq_names(example_data_path)[1:5]\n5-element Vector{String}:\n \"lcl|NC_000964.3_cds_NP_387882.1_1\"\n \"lcl|NC_000964.3_cds_NP_387883.1_2\"\n \"lcl|NC_000964.3_cds_NP_387884.1_3\"\n \"lcl|NC_000964.3_cds_NP_387885.1_4\"\n \"lcl|NC_000964.3_cds_NP_387886.2_5\"\n\njulia> seq_descriptions(example_data_path)[1]\n\"lcl|NC_000964.3_cds_NP_387882.1_1 [gene=dnaA] [locus_tag=BSU_00010] [db_xref=EnsemblGenomes-Gn:BSU00010,EnsemblGenomes-Tr:CAB11777,GOA:P05648,InterPro:IPR001957,InterPro:IPR003593,InterPro:IPR010921,InterPro:IPR013159,InterPro:IPR013317,InterPro:IPR018312,InterPro:IPR020591,InterPro:IPR024633,InterPro:IPR027417,PDB:4TPS,SubtiList:BG10065,UniProtKB/Swiss-Prot:P05648] [protein=chromosomal replication initiator informational ATPase] [protein_id=NP_387882.1] [location=410..1750] [gbkey=CDS]\"","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Once you have your reference vector, you can supply an argument to ref_seqs as a named tuple. If you have multiple reference sets you want to use, those can be included as additional entries in the ref_seqs tuple.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> b_ribo_result = b(example_data_path, ref_seqs = (ribosomal = ribosomal_genes,));\n\njulia> b_ribo_result.ribosomal\n3801-element Vector{Float64}:\n 0.27433079214149625\n 0.3206897249908304\n 0.25532544766240484\n 0.5464925047248634\n 0.22424329272203575\n 0.22684609299155567\n ⋮\n 0.2561376033448253\n 0.2217345501228918\n 0.40667338789742696\n 0.3758568749612823\n 0.4379807676614555\n\njulia> dna_genes = find_seqs(example_data_path, r\"dna|DNA|Dna\")\n4237-element Vector{Bool}:\n 1\n 1\n 0\n 1\n 0\n 1\n ⋮\n 0\n 1\n 0\n 0\n 0\n\njulia> b_multi_result = b(example_data_path, ref_seqs = (ribosomal = ribosomal_genes, DNA = dna_genes));\n\njulia> b_multi_result.ribosomal\n3801-element Vector{Float64}:\n 0.27433079214149625\n 0.3206897249908304\n 0.25532544766240484\n 0.5464925047248634\n 0.22424329272203575\n 0.22684609299155567\n ⋮\n 0.2561376033448253\n 0.2217345501228918\n 0.40667338789742696\n 0.3758568749612823\n 0.4379807676614555\n\njulia> b_multi_result.DNA\n3801-element Vector{Float64}:\n 0.2148821062833632\n 0.3182032724315858\n 0.23577274334969703\n 0.5371269155669846\n 0.2684310325581909\n 0.2860168153422687\n ⋮\n 0.273137416897346\n 0.21136319951043495\n 0.3866134722044515\n 0.3510891124098759\n 0.3668966776242405","category":"page"},{"location":"cub/#Other-Arguments","page":"Codon Usage Bias","title":"Other Arguments","text":"","category":"section"},{"location":"cub/#rm_stop","page":"Codon Usage Bias","title":"rm_stop","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Whether to remove stop codons from the calculation of codon usage bias. Default is false","category":"page"},{"location":"cub/#threshold","page":"Codon Usage Bias","title":"threshold","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"The minimum length of a gene in codons to be used when calculating codon usage bias. The default is 80; all genes under that length are discarded. If you want to discard no genes, set threshold = 0. You do not need to adjust your reference sequence vector when adjusting threshold values.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> b_result_0 = b(example_data_path, threshold = 0);\n\njulia> b_result_300 = b(example_data_path, threshold = 300);\n\njulia> length(b_result_0.self)\n4237\n\njulia> length(b_result_300.self)\n1650","category":"page"},{"location":"cub/#dataframe","page":"Codon Usage Bias","title":"dataframe","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"By default, results are returned as named tuples. If you would like a dataframe instead, set dataframe = true. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> b(example_data_path)\n(self = [0.20912699220973896, 0.3289759448740455, 0.22365336363593893, 0.5391135258658497, 0.24919594143501034, 0.2880358413249049, 0.31200964304415874, 0.34858035204347476, 0.2455189361074733, 0.4690734561271221  …  0.3629137353834403, 0.3621330537227321, 0.4535285720373026, 0.3357858047622507, 0.28183191395624935, 0.2668809561422238, 0.22381338105820905, 0.4034837015709619, 0.3594626865160133, 0.3724863965444541], Identifier = [\"lcl|NC_000964.3_cds_NP_387882.1_1\", \"lcl|NC_000964.3_cds_NP_387883.1_2\", \"lcl|NC_000964.3_cds_NP_387885.1_4\", \"lcl|NC_000964.3_cds_NP_387886.2_5\", \"lcl|NC_000964.3_cds_NP_387887.1_6\", \"lcl|NC_000964.3_cds_NP_387888.1_7\", \"lcl|NC_000964.3_cds_NP_387889.1_8\", \"lcl|NC_000964.3_cds_NP_387890.1_9\", \"lcl|NC_000964.3_cds_NP_387891.1_10\", \"lcl|NC_000964.3_cds_NP_387892.1_11\"  …  \"lcl|NC_000964.3_cds_NP_391976.1_4227\", \"lcl|NC_000964.3_cds_NP_391977.1_4228\", \"lcl|NC_000964.3_cds_NP_391978.2_4229\", \"lcl|NC_000964.3_cds_NP_391979.1_4230\", \"lcl|NC_000964.3_cds_NP_391980.1_4231\", \"lcl|NC_000964.3_cds_NP_391981.1_4232\", \"lcl|NC_000964.3_cds_NP_391982.1_4233\", \"lcl|NC_000964.3_cds_NP_391983.1_4234\", \"lcl|NC_000964.3_cds_NP_391984.1_4235\", \"lcl|NC_000964.3_cds_NP_391985.1_4236\"])\n\njulia> b(example_data_path, dataframe = true)\n3801×3 DataFrame\n  Row │ self      Identifier                         File                              \n      │ Float64   String                             String                            \n──────┼────────────────────────────────────────────────────────────────────────────────\n    1 │ 0.209127  lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…\n    2 │ 0.328976  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…\n    3 │ 0.223653  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…\n    4 │ 0.539114  lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…\n  ⋮   │    ⋮                      ⋮                                  ⋮\n 3799 │ 0.403484  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…\n 3800 │ 0.359463  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…\n 3801 │ 0.372486  lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…\n                                                                      3794 rows omitted","category":"page"},{"location":"cub/#Analyzing-Multiple-Files","page":"Codon Usage Bias","title":"Analyzing Multiple Files","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Often, you might have a directory containing multiple .fna files, each of which you want to analyze. You can provide a vector of filepaths to any CUBScout function, which will return a vector of results. If dataframe = true, results from multiple files will be verticaly concatenated. If supplying ref_seqs, provide a vector of named tuples corresponding to each file. CUBScout is multi-threaded, and if Julia is started with multiple threads, will assign individual threads to process individual files. This means you should not broadcast CUBScout functions as it will reduce efficiency. Also each file is only ever processed by a single thread, so using more threads than you have files is unnecessary. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> enc_p([example_data_path,example_data_path], dataframe = true)\n7602×3 DataFrame\n  Row │ self     Identifier                         File                              \n      │ Float64  String                             String                            \n──────┼───────────────────────────────────────────────────────────────────────────────\n    1 │ 61.0     lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…\n    2 │ 59.3698  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…\n    3 │ 60.7495  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…\n    4 │ 61.0     lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…\n  ⋮   │    ⋮                     ⋮                                  ⋮\n 7600 │ 59.9479  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…\n 7601 │ 59.4305  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…\n 7602 │ 61.0     lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…\n                                                                     7595 rows omitted\n\njulia> enc_p([example_data_path,example_data_path], ref_seqs = [(ribosomal = ribosomal_genes,), (ribosomal = ribosomal_genes,)], dataframe = true)\n7602×3 DataFrame\n  Row │ ribosomal  Identifier                         File                              \n      │ Float64    String                             String                            \n──────┼─────────────────────────────────────────────────────────────────────────────────\n    1 │   61.0     lcl|NC_000964.3_cds_NP_387882.1_1  /Users/augustuspendleton/.julia/…\n    2 │   58.8882  lcl|NC_000964.3_cds_NP_387883.1_2  /Users/augustuspendleton/.julia/…\n    3 │   56.4104  lcl|NC_000964.3_cds_NP_387885.1_4  /Users/augustuspendleton/.julia/…\n    4 │   61.0     lcl|NC_000964.3_cds_NP_387886.2_5  /Users/augustuspendleton/.julia/…\n  ⋮   │     ⋮                      ⋮                                  ⋮\n 7600 │   56.5325  lcl|NC_000964.3_cds_NP_391983.1_…  /Users/augustuspendleton/.julia/…\n 7601 │   55.6687  lcl|NC_000964.3_cds_NP_391984.1_…  /Users/augustuspendleton/.julia/…\n 7602 │   61.0     lcl|NC_000964.3_cds_NP_391985.1_…  /Users/augustuspendleton/.julia/…\n                                                                       7595 rows omitted","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CUBScout","category":"page"},{"location":"#CUBScout","page":"Home","title":"CUBScout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CUBScout calculates Codon Usage Bias (CUB) and related expressivity predictions. Currently, CUBScout calculates:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Six measures of codon usage bias:\nB, from Karlin and Mrazek, 1996\nENC, from Wright 1990\nENC', from Novembre, 2002\nMCB, from Urutia and Hurst, 2001\nMILC, from Supek and Vlahovicek, 2005\nSCUO, from Wan et al., 2004\nFive expressivity measures based on codon usage bias:\nCAI, from Sharp and Lee, 1987\nE, from Karlin and Mrazek, 1996\nFOP, from Ikemura, 1981\nGCB, from Merkl, 2003\nMELP, from Supek and Vlahovicek, 2005","category":"page"},{"location":"","page":"Home","title":"Home","text":"CUBScout is based off of the fabulous coRdon package in R by Anamaria Elek, Maja Kuzman, and Kristian Vlahovicek. I am grateful for their clear code and would encourage you to cite coRdon as well when using CUBScout.","category":"page"}]
}
