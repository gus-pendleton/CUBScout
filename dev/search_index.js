var documenterSearchIndex = {"docs":
[{"location":"exp/#Expressivity-Predictions","page":"Expressivity Prediction","title":"Expressivity Predictions","text":"","category":"section"},{"location":"exp/#Under-default-conditions","page":"Expressivity Prediction","title":"Under default conditions","text":"","category":"section"},{"location":"exp/","page":"Expressivity Prediction","title":"Expressivity Prediction","text":"Expressivity predictions based on codon usage bias can be calculated with the functions cai(), e(), fop(), gcb(), and melp(). All expressivity functions (besides gcb) require two arguments:","category":"page"},{"location":"exp/","page":"Expressivity Prediction","title":"Expressivity Prediction","text":"sequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment.  If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of BioSequences, with each vector corresponding to a genome.\nref_vector(s): Vector{Bool} or Vector{Vector{Bool}} identifying reference subsets for each file.","category":"page"},{"location":"exp/","page":"Expressivity Prediction","title":"Expressivity Prediction","text":"note: Why do expressivity functions accept reference subsets in a different format than codon usage bias functions?\nYou may have noticed that for codon usage bias functions, you need to provide a named tupled of reference sequences, while in expressivity functions, you just need to provide the vector. Why did I make this so complicated for you? Well, for expressivity functions, a reference subset is required, and you can only provide a single reference subset. Because this is more strict, the function could be written less flexibly. However, codon usage bias functions can accept no reference subsets, one reference subset, or multiple reference subsets. As such, the named tuple format is necessary to differentiate your input and provide differentiated output.","category":"page"},{"location":"exp/","page":"Expressivity Prediction","title":"Expressivity Prediction","text":"Let's calculate MELP on our example data, using ribosomal proteins as a reference subset. ","category":"page"},{"location":"exp/","page":"Expressivity Prediction","title":"Expressivity Prediction","text":"julia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\");\n\njulia> melp_result = melp(EXAMPLE_DATA_PATH, ribosomal_genes);\n\njulia> melp_result.MELP\n3801-element Vector{Float64}:\n 0.9294138732153456\n 1.007671319249364\n 0.9223573085968517\n 0.9512392602630869\n 1.0295311265835025\n 1.0749743120487463\n ⋮\n 1.0147105407479773\n 0.9929945778238751\n 0.9682178480589456\n 0.9651731383865032\n 0.8840414848184831","category":"page"},{"location":"exp/","page":"Expressivity Prediction","title":"Expressivity Prediction","text":"The functions cai, e, fop, and melp all accept the same arguments. Their optional arguments are the same as codon usage bias functions, including options to specify a custom CodonDict, remove start or stop codons, and set a filtering threshold. They also handle multiple files and multi-threading in the same way, and so I do not recommend broadcasting these functions.","category":"page"},{"location":"exp/#GCB-specific-Arguments","page":"Expressivity Prediction","title":"GCB-specific Arguments","text":"","category":"section"},{"location":"exp/","page":"Expressivity Prediction","title":"Expressivity Prediction","text":"Because of the iterative way GCB is calculated, its arguments differ slightly from other expressivity functions. Namely:","category":"page"},{"location":"exp/","page":"Expressivity Prediction","title":"Expressivity Prediction","text":"GCB uses a \"seed\" reference subset. By default, this is set to \"self\", and so is an optional argument. Custom ref_vector(s) can be supplied if so desired, as a keyword argument\nGCB iteratively calculates the GCB measure and then uses the genes with highest GCB values as a reference subset in the next iteration. The perc argument specifies what percent of the of genes is used a reference subset. By default, perc = 0.05, or 5%. ","category":"page"},{"location":"functions/#Index-of-Functions","page":"Functions","title":"Index of Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [CUBScout]","category":"page"},{"location":"functions/#CUBScout.EXAMPLE_DATA_PATH","page":"Functions","title":"CUBScout.EXAMPLE_DATA_PATH","text":"EXAMPLE_DATA_PATH\n\nThe path to an example dataset, stored as an artifact within the package. This is an .fna file containing coding sequences from Bacillus subtilis subsp. subtilis str. 168, NCBI Accession # NC_000964.3.\n\n\n\n\n\n","category":"constant"},{"location":"functions/#CUBScout.CodonDict","page":"Functions","title":"CUBScout.CodonDict","text":"CodonDict\n\nThe CodonDict type defines how codons are translated, and is essential for calculating codon usage bias as it identifies stop codons and each amino acid's degeneracy. A default codon dictionary is provided (default_codon_dict), or a user can make their own using the make_codon_dict function.\n\nFields\n\ncodons: the 64 codons, in alphabetical order\nAA: corresponding amino acid for each codon (64 entries long)\nAA_nostops: same as AA, but with stop codons removed\nuniqueAA: unique amino acid names including stop codons. Under a standard translation table, this is 21 amino acids long\nuniqueAA: same as uniqueAA, but with stop codons removed\nuniqueI: a vector of the same length as uniqueAA, containing vectors of the indices of each codon for that amino acid. For instance, the first entry corresponds to Lysine, and contains the vector [1, 3], corresponding to the positions of codons AAA and AAG in the codons field\nuniqueI_nostops: same as uniqueI, but with stop codons removed\ndeg: a vector of the same length as uniqueAA, containing the degeneracy for each amino acid.\ndeg_nostops: same as deg, but with stop codons removed\nstop_mask: a Boolean vector of length 64 which is false for stop codons. This is used to remove stop codons when calculating codon usage bias.\n\nNotes\n\nGenerally, CUBScout users shouldn't need to interact with the CodonDict type, as the standard genetic code is applied by default. Details for constructing a custom CodonDict are documented under the make_CodonDict function.\n\n\n\n\n\n","category":"type"},{"location":"functions/#CUBScout.all_cub","page":"Functions","title":"CUBScout.all_cub","text":"all_cub(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80)\nall_cub(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate all codon usage bias measures at once. Because many measures require the same initial calculations, this is more efficient than calculating them individually.\n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> all_cub_results = all_cub(EXAMPLE_DATA_PATH); # Calculate all six codon usage measures on example dataset\n\njulia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> all_cub(EXAMPLE_DATA_PATH, ref_seqs = (ribosomal = ribosomal_genes,)); # Calculate all measures using ribosomal genes as a reference subset\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.b","page":"Functions","title":"CUBScout.b","text":"b(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80)\nb(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate B from Karlin and Mrazek, 1996. \n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nref_seqs: by default, codon usage bias for each gene is calculated using the whole genome (\"self\") as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, ref_seqs takes a named tuple in the form (\"subset_name\" = Bool[],), where Bool[] is the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and CUBScout will return the calculated measure using each subset. If providing multiple sets of sequences and want custom reference sets, ref_seqs should be a vector of named tuples corresponding to the vector of sequences.\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> result = b(EXAMPLE_DATA_PATH); # Calculate measure on example dataset\n\njulia> result_300 = b(EXAMPLE_DATA_PATH, threshold = 300); # Increase threshold length\n\njulia> length(result.self)\n3801\n\njulia> length(result_300.self)\n1650\n\njulia> round.(result.self[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.209127\n 0.328976\n 0.223653\n 0.539114\n 0.249196\n\njulia> b(EXAMPLE_DATA_PATH, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> b(EXAMPLE_DATA_PATH, rm_start = true); # Remove start codons\n\njulia> all_genes = find_seqs(EXAMPLE_DATA_PATH, r\"\"); # Get a vector which is true for all genes\n\njulia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> b(EXAMPLE_DATA_PATH, ref_seqs = (ribosomal = ribosomal_genes,)); # Calculate using ribosomal genes as a reference subset\n\njulia> b(EXAMPLE_DATA_PATH, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,)); # Calculate using all genes and ribosomal genes as a reference subset\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.cai","page":"Functions","title":"CUBScout.cai","text":"cai(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, ref_vector::Vector{Bool}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\ncai(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, ref_vectors::Vector{Vector{Bool}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate CAI from Sharp and Li, 1987.\n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\nref_vector: reference subset, which is required for cai. Bool[] the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. If providing multiple filepaths and want custom reference sets, ref_vectors should be a vector of vectors corresponding to the vector of filepaths.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> result = cai(EXAMPLE_DATA_PATH, ribosomal_genes); # Calculate CAI on example dataset\n\njulia> round.(result.CAI[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.844967\n 0.88548\n 0.817348\n 1.072675\n 0.834179\n\njulia> cai(EXAMPLE_DATA_PATH, ribosomal_genes, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> cai(EXAMPLE_DATA_PATH, ribosomal_genes, rm_start = true); # Remove start codons\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.codon_frequency","page":"Functions","title":"CUBScout.codon_frequency","text":"codon_frequency(codon_counts::Matrix{<:Integer}, form::String, dict::CodonDict = DEFAULT_CodonDict)\n\nCalculate codon frequency from a matrix of codon counts. Accepts as its first argument a Matrix{<:Integer} which is a product of count_codons(). form can be one of four options: -net_genomic: Frequency of each codon across entire genome (matrix). -net_gene: Frequency of each codon within each gene (column). -byAA_genomic: Frequency of each codon within each amino acid across the entire genome (matrix). -byAA_gene: Frequency of each codon within each amino acid within each gene (column). \n\nIf using an alternative genetic code, a custom CodonDict can be provided.\n\nExamples\n\njulia> codon_counts = count_codons(EXAMPLE_DATA_PATH);\n\njulia> count_matrix = codon_counts[1];\n\njulia> codon_frequency(count_matrix, \"net_genomic\")[1:5]\n5-element Vector{Float64}:\n 0.04941242971710299\n 0.017114892645228374\n 0.021009352696846777\n 0.022269444158755328\n 0.022257296747490142\n\njulia> codon_frequency(count_matrix, \"net_genomic\") |> size\n(64, 1)\n\njulia> codon_frequency(count_matrix, \"net_gene\") |> size\n(64, 4237)\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.count_codons","page":"Functions","title":"CUBScout.count_codons","text":"count_codons(path::AbstractString, remove_start::Bool = false, threshold::Integer = 0)\ncount_codons(stream::IO, remove_start::Bool = false, threshold::Integer = 0)\ncount_codons(reader::FASTAReader, remove_start::Bool = false, threshold::Integer = 0)\ncount_codons(sequences::Vector{<:NucSeq}, names::Vector{String} = String[], remove_start::Bool = false, threshold::Integer = 0)\ncount_codons(sequence::NucSeq, remove_start::Bool = false, threshold::Integer = 0)\n\nRead a fasta file or BioSequence and return the occurence of each codon for each gene or sequence.\n\nArguments\n\npath or stream or reader or sequence(s): Fasta sequence to analyze. This can be a path to a fasta file of sequences, an IOStream, an open FASTAReader, or a BioSequences nucleotide sequence, or a vector of nucleotide sequences. Note that count_codons isn't identifying ORFs - make sure these are actual CDSs in frame.\nremove_start: Whether to ignore the initial start codon\nthreshold: Minimum length of the sequence in codons to be returned in the results.\n\nOutput\n\nIf providing a single sequence, the result will be a 64x1 Matrix, which corresponds to the 64 codons in alphabetical order. If you want a list of the codons in alphabetical order, this is stored in CUBScout.DEFAULT_CodonDict.codons. If analyzing a fasta file or a vector of sequences, the result will be a tuple. The first element of the tuple is a 64xn matrix, where n = # of sequences above the threshold. The second element is a list of corresponding names for each column. The third element is a Boolean vector where true corresponds to sequences which did pass the threshold, and false is sequences which did not pass the threshold and so are not included in the results matrix. Names are pulled from fasta files and IO streams by default; if you would like to provide a vector of IDs or names when providing a Vector{<:NucSeq}, you can.\n\nExamples\n\njulia> using BioSequences: @dna_str\n\njulia> example_dna = dna\"ATGAAAATGAACTTTTGA\"\n18nt DNA Sequence:\nATGAAAATGAACTTTTGA\n\njulia> count_codons(example_dna) |> first\n1\n\njulia> result = count_codons(EXAMPLE_DATA_PATH);\n\njulia> first(result[1], 5)\n5-element Vector{Int32}:\n 32\n  7\n  6\n 14\n 11\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.e","page":"Functions","title":"CUBScout.e","text":"e(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, ref_vector::Vector{Bool}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\ne(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, ref_vectors::Vector{Vector{Bool}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate E from Karlin and Mrazek, 1996.\n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\nref_vector: reference subset, which is required for e. Bool[] the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. If providing multiple filepaths and want custom reference sets, ref_vectors should be a vector of vectors corresponding to the vector of filepaths.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> result = e(EXAMPLE_DATA_PATH, ribosomal_genes); # Calculate E on example dataset\n\njulia> round.(result.E[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.762317\n 1.025839\n 0.875954\n 0.986498\n 1.111275\n\njulia> e(EXAMPLE_DATA_PATH, ribosomal_genes, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> e(EXAMPLE_DATA_PATH, ribosomal_genes, rm_start = true); # Remove start codons\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.enc","page":"Functions","title":"CUBScout.enc","text":"enc(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\nenc(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate ENC from Wright, 1990.  \n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> result = enc(EXAMPLE_DATA_PATH); # Run ENC on example dataset\n\njulia> round.(result.ENC[1:5], digits = 6)\n5-element Vector{Float64}:\n 56.787282\n 52.725947\n 59.287949\n 52.296686\n 55.262981\n\njulia> result_300 = enc(EXAMPLE_DATA_PATH, threshold = 300); # Increase threshold length\n\njulia> length(result.ENC)\n3801\n\njulia> length(result_300.ENC)\n1650\n\njulia> enc(EXAMPLE_DATA_PATH, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> enc(EXAMPLE_DATA_PATH, rm_start = true); # Remove start codons\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.enc_p","page":"Functions","title":"CUBScout.enc_p","text":"enc_p(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80)\nenc_p(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate ENC' from Novembre, 2002. \n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nref_seqs: by default, codon usage bias for each gene is calculated using the whole genome (\"self\") as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, ref_seqs takes a named tuple in the form (\"subset_name\" = Bool[],), where Bool[] is the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and CUBScout will return the calculated measure using each subset. If providing multiple sets of sequences and want custom reference sets, ref_seqs should be a vector of named tuples corresponding to the vector of sequences.\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> result = enc_p(EXAMPLE_DATA_PATH); # Calculate measure on example dataset\n\njulia> result_300 = enc_p(EXAMPLE_DATA_PATH, threshold = 300); # Increase threshold length\n\njulia> length(result.self)\n3801\n\njulia> length(result_300.self)\n1650\n\njulia> round.(result.self[1:5], digits = 6)\n5-element Vector{Float64}:\n 61.0\n 59.369798\n 60.749462\n 61.0\n 61.0\n\njulia> enc_p(EXAMPLE_DATA_PATH, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> enc_p(EXAMPLE_DATA_PATH, rm_start = true); # Remove start codons\n\njulia> all_genes = find_seqs(EXAMPLE_DATA_PATH, r\"\"); # Get a vector which is true for all genes\n\njulia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> enc_p(EXAMPLE_DATA_PATH, ref_seqs = (ribosomal = ribosomal_genes,)); # Calculate using ribosomal genes as a reference subset\n\njulia> enc_p(EXAMPLE_DATA_PATH, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,)); # Calculate using all genes and ribosomal genes as a reference subset\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.find_seqs-Tuple{AbstractString, Regex}","page":"Functions","title":"CUBScout.find_seqs","text":"find_seqs(path::AbstractString, match_pattern::Regex)\nfind_seqs(stream::IO, match_pattern::Regex)\nfind_seqs(reader::FASTAReader, match_pattern::Regex)\n\nRead a fasta file at path (or reader or IO which points to a fasta file) and query the description field for a given Regex match_pattern. These results can be supplied in either the reference tuples (for codon usage bias functions) or reference vectors (for expressivity measures).\n\nExamples\n\njldoctest julia> find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\")[1:5] 5-element Vector{Bool}:  0  0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"functions/#CUBScout.fop","page":"Functions","title":"CUBScout.fop","text":"fop(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, ref_vector::Vector{Bool}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\nfop(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, ref_vectors::Vector{Vector{Bool}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate FOP from Ikemura, 1981.\n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\nref_vector: reference subset, which is required for fop. Bool[] the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. If providing multiple filepaths and want custom reference sets, ref_vectors should be a vector of vectors corresponding to the vector of filepaths.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> result = fop(EXAMPLE_DATA_PATH, ribosomal_genes); # Calculate CAI on example dataset\n\njulia> round.(result.FOP[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.567816\n 0.566845\n 0.509695\n 0.725\n 0.653784\n\njulia> fop(EXAMPLE_DATA_PATH, ribosomal_genes, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> fop(EXAMPLE_DATA_PATH, ribosomal_genes, rm_start = true); # Remove start codons\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.gcb","page":"Functions","title":"CUBScout.gcb","text":"gcb(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, ref_vector = [], perc = 0.05, rm_start = false, rm_stop = false, threshold = 80)\ngcb(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, ref_vectors = [], perc = 0.05, rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate GCB from Merkl, 2003.\n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of BioSequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each fasta file or vector of BioSequences. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nref_vector: optional reference subset; by default gcb begins calculations using all genes as a seed. If you want to provide a custom reference set, it should be a vector Bool[] the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. If providing multiple filepaths and want custom reference sets, ref_vectors should be a vector of vectors corresponding to the vector of filepaths.\nperc: percentage of \"top hits\" which should be used as a reference set in the next iteration. By default set to 0.05. \nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> result = gcb(EXAMPLE_DATA_PATH); # Calculate GCB on example dataset\n\njulia> round.(result.GCB[1:5], digits = 6)\n5-element Vector{Float64}:\n -0.058765\n -0.08659\n -0.005496\n -0.065659\n -0.032062\n\njulia> ribo_result = gcb(EXAMPLE_DATA_PATH, ref_vector = ribosomal_genes); # Calculate GCB with ribosomal genes as reference seed example dataset\n\njulia> round.(ribo_result.GCB[1:5], digits = 6)\n5-element Vector{Float64}:\n -0.135615\n -0.036687\n -0.169136\n -0.186104\n -0.01653\n\njulia> gcb(EXAMPLE_DATA_PATH, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> gcb(EXAMPLE_DATA_PATH, rm_start = true); # Remove start codons\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.make_CodonDict","page":"Functions","title":"CUBScout.make_CodonDict","text":"make_CodonDict(filepath::AbstractString, delimiter::AbstractChar = '\t')\n\nMake a custom codon dictionary for organisms with non-standard genetic code. filepath points to a delimited file with two columns and no header. The first column should be codons, and the second column their corresponding amino acid. Avoid spaces and special characters (e.g., write GlutamicAcid instead of Glutamic Acid). Stop codons can be coded as Stop, stop, STOP, or *. If delimited using any character outside of tab, supply the delimiter as the second argument as Char, not a string (e.g. ',' not \",\"). make_CodonDict uses readdlm from DelimitedFiles; it's a good idea to check whether readdlm parses your file correctly before passing to make_CodonDict\n\nExamples\n\njulia> my_CodonDict = make_CodonDict(CUBScout.CodonDict_PATH)\nCodonDict(BioSequences.LongSequence{BioSequences.DNAAlphabet{2}}[AAA, AAC, AAG, AAT, ACA, ACC, ACG, ACT, AGA, AGC  …  TCG, TCT, TGA, TGC, TGG, TGT, TTA, TTC, TTG, TTT], [\"Lysine\", \"Asparagine\", \"Lysine\", \"Asparagine\", \"Threonine\", \"Threonine\", \"Threonine\", \"Threonine\", \"Arginine\", \"Serine\"  …  \"Serine\", \"Serine\", \"Stop\", \"Cysteine\", \"Tryptophan\", \"Cysteine\", \"Leucine\", \"Phenylalanine\", \"Leucine\", \"Phenylalanine\"], [\"Lysine\", \"Asparagine\", \"Lysine\", \"Asparagine\", \"Threonine\", \"Threonine\", \"Threonine\", \"Threonine\", \"Arginine\", \"Serine\"  …  \"Serine\", \"Serine\", \"Serine\", \"Cysteine\", \"Tryptophan\", \"Cysteine\", \"Leucine\", \"Phenylalanine\", \"Leucine\", \"Phenylalanine\"], [\"Lysine\", \"Asparagine\", \"Threonine\", \"Arginine\", \"Serine\", \"Isoleucine\", \"Methionine\", \"Glutamine\", \"Histidine\", \"Proline\"  …  \"Glutamicacid\", \"Asparticacid\", \"Alanine\", \"Glycine\", \"Valine\", \"Stop\", \"Tyrosine\", \"Cysteine\", \"Tryptophan\", \"Phenylalanine\"], [\"Lysine\", \"Asparagine\", \"Threonine\", \"Arginine\", \"Serine\", \"Isoleucine\", \"Methionine\", \"Glutamine\", \"Histidine\", \"Proline\", \"Leucine\", \"Glutamicacid\", \"Asparticacid\", \"Alanine\", \"Glycine\", \"Valine\", \"Tyrosine\", \"Cysteine\", \"Tryptophan\", \"Phenylalanine\"], Vector{Int32}[[1, 3], [2, 4], [5, 6, 7, 8], [9, 11, 25, 26, 27, 28], [10, 12, 53, 54, 55, 56], [13, 14, 16], [15], [17, 19], [18, 20], [21, 22, 23, 24]  …  [33, 35], [34, 36], [37, 38, 39, 40], [41, 42, 43, 44], [45, 46, 47, 48], [49, 51, 57], [50, 52], [58, 60], [59], [62, 64]], Vector{Int32}[[1, 3], [2, 4], [5, 6, 7, 8], [9, 11, 25, 26, 27, 28], [10, 12, 51, 52, 53, 54], [13, 14, 16], [15], [17, 19], [18, 20], [21, 22, 23, 24], [29, 30, 31, 32, 58, 60], [33, 35], [34, 36], [37, 38, 39, 40], [41, 42, 43, 44], [45, 46, 47, 48], [49, 50], [55, 57], [56], [59, 61]], Int32[2, 2, 4, 6, 6, 3, 1, 2, 2, 4  …  2, 2, 4, 4, 4, 3, 2, 2, 1, 2], Int32[2, 2, 4, 6, 6, 3, 1, 2, 2, 4, 6, 2, 2, 4, 4, 4, 2, 2, 1, 2], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  1, 1, 0, 1, 1, 1, 1, 1, 1, 1])\n\njulia> typeof(my_CodonDict)\nCodonDict\n\njulia> fieldnames(CodonDict)\n(:codons, :AA, :AA_nostops, :uniqueAA, :uniqueAA_nostops, :uniqueI, :uniqueI_nostops, :deg, :deg_nostops, :stop_mask)\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.mcb","page":"Functions","title":"CUBScout.mcb","text":"mcb(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80)\nmcb(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate MCB from Urrutia and Hurst, 2001.\n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nref_seqs: by default, codon usage bias for each gene is calculated using the whole genome (\"self\") as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, ref_seqs takes a named tuple in the form (\"subset_name\" = Bool[],), where Bool[] is the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and CUBScout will return the calculated measure using each subset. If providing multiple sets of sequences and want custom reference sets, ref_seqs should be a vector of named tuples corresponding to the vector of sequences.\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> result = mcb(EXAMPLE_DATA_PATH); # Calculate measure on example dataset\n\njulia> result_300 = mcb(EXAMPLE_DATA_PATH, threshold = 300); # Increase threshold length\n\njulia> length(result.self)\n3801\n\njulia> length(result_300.self)\n1650\n\njulia> round.(result.self[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.087211\n 0.178337\n 0.189682\n 0.24012\n 0.149869\n\njulia> mcb(EXAMPLE_DATA_PATH, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> mcb(EXAMPLE_DATA_PATH, rm_start = true); # Remove start codons\n\njulia> all_genes = find_seqs(EXAMPLE_DATA_PATH, r\"\"); # Get a vector which is true for all genes\n\njulia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> mcb(EXAMPLE_DATA_PATH, ref_seqs = (ribosomal = ribosomal_genes,)); # Calculate using ribosomal genes as a reference subset\n\njulia> mcb(EXAMPLE_DATA_PATH, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,)); # Calculate using all genes and ribosomal genes as a reference subset\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.melp","page":"Functions","title":"CUBScout.melp","text":"melp(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, ref_vector::Vector{Bool}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\nmelp(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, ref_vectors::Vector{Vector{Bool}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate MELP from Supek and Vlahovicek, 2005.\n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\nref_vector: reference subset, which is required for melp. Bool[] the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. If providing multiple filepaths and want custom reference sets, ref_vectors should be a vector of vectors corresponding to the vector of filepaths.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> result = melp(EXAMPLE_DATA_PATH, ribosomal_genes); # Calculate MELP on example dataset\n\njulia> round.(result.MELP[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.929414\n 1.007671\n 0.922357\n 0.951239\n 1.029531\n\njulia> melp(EXAMPLE_DATA_PATH, ribosomal_genes, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> melp(EXAMPLE_DATA_PATH, ribosomal_genes, rm_start = true); # Remove start codons\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.milc","page":"Functions","title":"CUBScout.milc","text":"milc(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80)\nmilc(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, ref_seqs = (), rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate MILC from Supek and Vlahovicek, 2005.\n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nref_seqs: by default, codon usage bias for each gene is calculated using the whole genome (\"self\") as a reference subset. If you would like to specify your own subsets to calculate against, such as ribosomal genes, ref_seqs takes a named tuple in the form (\"subset_name\" = Bool[],), where Bool[] is the same length as the number of sequences in your fasta file, and contains true for sequences you want as your reference subset and false for those you don't. You can use find_seqs() to generate this vector. You can provide multiple reference subsets as separate entries in the named tuple, and CUBScout will return the calculated measure using each subset. If providing multiple sets of sequences and want custom reference sets, ref_seqs should be a vector of named tuples corresponding to the vector of sequences.\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> result = milc(EXAMPLE_DATA_PATH); # Calculate measure on example dataset\n\njulia> result_300 = milc(EXAMPLE_DATA_PATH, threshold = 300); # Increase threshold length\n\njulia> length(result.self)\n3801\n\njulia> length(result_300.self)\n1650\n\njulia> round.(result.self[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.494826\n 0.583944\n 0.499472\n 0.635493\n 0.543935\n\njulia> milc(EXAMPLE_DATA_PATH, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> milc(EXAMPLE_DATA_PATH, rm_start = true); # Remove start codons\n\njulia> all_genes = find_seqs(EXAMPLE_DATA_PATH, r\"\"); # Get a vector which is true for all genes\n\njulia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\"); # Get a vector which is true for ribosomal genes\n\njulia> milc(EXAMPLE_DATA_PATH, ref_seqs = (ribosomal = ribosomal_genes,)); # Calculate using ribosomal genes as a reference subset\n\njulia> milc(EXAMPLE_DATA_PATH, ref_seqs = (self = all_genes, ribosomal = ribosomal_genes,)); # Calculate using all genes and ribosomal genes as a reference subset\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.scuo","page":"Functions","title":"CUBScout.scuo","text":"scuo(sequences::Union{String, IO, FASTAReader, Vector{<:NucSeq}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{String}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\nscuo(sequences::Union{Vector{String}, Vector{<:IO}, Vector{<:FASTAReader}, Vector{<:Vector{<:NucSeq}}}, dict::CodonDict = DEFAULT_CodonDict; names::Union{Vector{Vector{String}}, Nothing} = nothing, rm_start = false, rm_stop = false, threshold = 80)\n\nCalculate SCUO from Wan et al., 2004.  \n\nArguments\n\nsequences: DNA or RNA sequences to be analyzed, which should be coding sequences only. This can take quite a few forms depending on your use case. It can be a path to fasta file of coding sequences (e.g. .fasta, .fna, .fa), or a IO or FASTAReader pointing to these fasta files. It can also be a vector of BioSequences, if you've already brought them into Julia's environment. There are no quality checks, so it's assumed that each entry is assumed to be an individual coding sequence, in the correct frame, without 5' or 3' untranslated regions. If you are analyzing multiple genomes (or sets of sequences), sequences could instead be a vector of filepaths, IOStreams, FASTAReaders, or vectors of sequences, with each vector corresponding to a genome. CUBScout is multithreaded; if there are multiple threads available, CUBScout will allocate a thread for each filepath. As such, providing a vector of filepaths (or Vector{<:Vector{<:NucSeq}}) as an argument will be faster than broadcasting across a vector of paths. Because a single file is only accessed by a single thread, it's never worth using more threads than the total number of files being analyzed.\ndict: codon dictionary of type CodonDict. The standard genetic code is loaded by default, but if necessary you can create your own codon dictionary using make_CodonDict\nnames: An optional vector of names for each sequence. Only relevant if providing a vector of BioSequences, as names are automatically pulled from fasta files. If sequences is of type Vector{<:Vector{<:NucSeq}}, names should be of type Vector{Vector{String}}\nrm_start: whether to ignore the first codon of each sequence. Many organisms use alternative start codons such as TTG and CTG, which in other locations would generally code for leucine. There are a few approaches to deal with this. By default, CUBScout keeps each start codon and assigns it as though it were any other codon. Of course, this would slightly change leucine's contribution to codon usage bias. If you set rm_start to true, the first codon of every sequence is simply discarded. This will also affect the gene's length, which means it could be removed if it falls under the threshold. Other CUB packages (such as R's coRdon, alt.init = TRUE), assign all TTG and CTG codons to methionine, regardless of their location. I disagree with this approach from a biological perspective; those codons still code for leucine most of the time they are used. However, if you want matching output as you would get from coRdon, you can supply ALTSTART_CodonDict to the dict argument, and keep rm_start as false.\nrm_stop: whether to remove stop codons from calculations of codon usage bias.\nthreshold: minimum length of a gene (in codons) to be used in codon usage bias calculations. By default this is set to 80 codons; any genes less than or equal to that length are discarded. If you want no genes discarded, set threshold to 0.\n\nExamples\n\njulia> result = scuo(EXAMPLE_DATA_PATH); # Run SCUO on example dataset\n\njulia> round.(result.SCUO[1:5], digits = 6)\n5-element Vector{Float64}:\n 0.143121\n 0.191237\n 0.096324\n 0.345211\n 0.105744\n\njulia> result_300 = scuo(EXAMPLE_DATA_PATH, threshold = 300); # Increase threshold length\n\njulia> length(result.SCUO)\n3801\n\njulia> length(result_300.SCUO)\n1650\n\njulia> scuo(EXAMPLE_DATA_PATH, ALTSTART_CodonDict); # Code TTG and CTG as methionine\n\njulia> scuo(EXAMPLE_DATA_PATH, rm_start = true); # Remove start codons\n\n\n\n\n\n","category":"function"},{"location":"functions/#CUBScout.seq_descriptions-Tuple{AbstractString}","page":"Functions","title":"CUBScout.seq_descriptions","text":"seq_descriptions(path::AbstractString)\nseq_descriptions(reader::FASTAReader)\nseq_descriptions(stream::IO)\n\nRead a fasta file at path and return the description fields. Just adds convenience on top of FASTX functions.\n\nExamples\n\njulia> seq_descr = seq_descriptions(EXAMPLE_DATA_PATH);\n\njulia> seq_descr[1]\n\"lcl|NC_000964.3_cds_NP_387882.1_1 [gene=dnaA] [locus_tag=BSU_00010] [db_xref=EnsemblGenomes-Gn:BSU00010,EnsemblGenomes-Tr:CAB11777,GOA:P05648,InterPro:IPR001957,InterPro:IPR003593,InterPro:IPR010921,InterPro:IPR013159,InterPro:IPR013317,InterPro:IPR018312,InterPro:IPR020591,InterPro:IPR024633,InterPro:IPR027417,PDB:4TPS,SubtiList:BG10065,UniProtKB/Swiss-Prot:P05648] [protein=chromosomal replication initiator informational ATPase] [protein_id=NP_387882.1] [location=410..1750] [gbkey=CDS]\"\n\n\n\n\n\n","category":"method"},{"location":"functions/#CUBScout.seq_names-Tuple{AbstractString}","page":"Functions","title":"CUBScout.seq_names","text":"seq_names(path::AbstractString)\nseq_names(reader::FASTAReader)\nseq_names(stream::IO)\n\nRead a fasta file at path and return the name fields. Just adds convenience on top of FASTX functions.\n\nExamples\n\njulia> seq_name_vector = seq_names(EXAMPLE_DATA_PATH);\n\njulia> seq_name_vector[1]\n\"lcl|NC_000964.3_cds_NP_387882.1_1\"\n\n\n\n\n\n","category":"method"},{"location":"cub/#Calculating-Codon-Usage-Bias","page":"Codon Usage Bias","title":"Calculating Codon Usage Bias","text":"","category":"section"},{"location":"cub/#Under-default-parameters","page":"Codon Usage Bias","title":"Under default parameters","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Codon usage bias can be calculated using the functions b(), enc(), enc_p(), mcb(), milc() and scuo(). These functions accept fasta-formatted files or vectors of BioSequences. If analyzing fasta files, these functions can accept filepaths as a string, an open IO, or an open FASTAReader. If providing a vector of BioSequences, the sequence can use either DNA or RNA alphabets. The output is a vector giving the codon usage bias of each coding sequence in the fasta file. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"warning: Warning\nCUBScout does not identify ORFs, pause at stop codons, or parse non-nucleotide characters. It is assumed the coding sequences you provide are in-frame and don't contain 5' or 3' untranslated regions. Codons which have non-specific nucleotides, like \"W\", are skipped. Sequences with characters outside of those recognized by BioSequences will throw an error.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"CUBScout is loaded with an example dataset, which can accessed at CUBScout.EXAMPLE_DATA_PATH. This string points to a .fna of coding sequences from B. subtilis. Let's calculate ENC for the genes in this file. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> EXAMPLE_DATA_PATH\n\"/your/path/to/file/B_subtilis.fna\"\n\njulia> enc_result = enc(EXAMPLE_DATA_PATH);\n\njulia> enc_result.ENC\n3801-element Vector{Float64}:\n 56.787282202547104\n 52.725946690067296\n 59.287948966886226\n 52.29668642771212\n 55.26298060679466\n 53.44161579771853\n  ⋮\n 50.30390962534221\n 56.29539618087172\n 55.229391962859935\n 52.58401385627267\n 60.19275631834157\n\njulia> enc_result.Identifier\n3801-element Vector{String}:\n \"lcl|NC_000964.3_cds_NP_387882.1_1\"\n \"lcl|NC_000964.3_cds_NP_387883.1_2\"\n \"lcl|NC_000964.3_cds_NP_387885.1_4\"\n \"lcl|NC_000964.3_cds_NP_387886.2_5\"\n \"lcl|NC_000964.3_cds_NP_387887.1_6\"\n \"lcl|NC_000964.3_cds_NP_387888.1_7\"\n ⋮\n \"lcl|NC_000964.3_cds_NP_391981.1_4232\"\n \"lcl|NC_000964.3_cds_NP_391982.1_4233\"\n \"lcl|NC_000964.3_cds_NP_391983.1_4234\"\n \"lcl|NC_000964.3_cds_NP_391984.1_4235\"\n \"lcl|NC_000964.3_cds_NP_391985.1_4236\"","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"ENC and SCUO calculate codon usage bias against a theoretical, unbiased distribution, and so simply return a named tuple containing ENC/SCUO and then the gene identifiers. B, ENC', MCB, and MILC calculate an expected codon frequency using a reference set of the genome, and then calculate codon usage bias for each gene against that reference set. As such, these functions return a named tuple which describes which reference set was used, alongside gene identifiers. By default, the codon usage bias is calculated against the codon usage bias of the genome as a whole, which we typically refer to as \"self\".","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> b_result = b(EXAMPLE_DATA_PATH)\n(self = [0.20912699220973896, 0.3289759448740455, 0.22365336363593893, 0.5391135258658497, 0.24919594143501034, 0.2880358413249049, 0.31200964304415874, 0.34858035204347476, 0.2455189361074733, 0.4690734561271221  …  0.3629137353834403, 0.3621330537227321, 0.4535285720373026, 0.3357858047622507, 0.28183191395624935, 0.2668809561422238, 0.22381338105820905, 0.4034837015709619, 0.3594626865160133, 0.3724863965444541],)\n\njulia> b_result.self\n3801-element Vector{Float64}:\n 0.20912699220973896\n 0.3289759448740455\n 0.22365336363593893\n 0.5391135258658497\n 0.24919594143501034\n 0.2880358413249049\n ⋮\n 0.2668809561422238\n 0.22381338105820905\n 0.4034837015709619\n 0.3594626865160133\n 0.3724863965444541","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Many of these measures rely on the same initial calculations. If you want to calculate all six measures at the same time, use the function all_cub(). This only runs these initial calculations once before calculating individual codon usage measures, and as such is more efficient than running all the functions separately. By default, all_cub returns a named tuple, each key of which corresponds to a different codon usage bias measure.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> all_cub_result = all_cub(EXAMPLE_DATA_PATH);\n\njulia> all_cub_result.B.self\n3801-element Vector{Float64}:\n 0.20912699220973896\n 0.3289759448740455\n 0.22365336363593893\n 0.5391135258658497\n 0.24919594143501034\n 0.2880358413249049\n ⋮\n 0.2668809561422238\n 0.22381338105820905\n 0.4034837015709619\n 0.3594626865160133\n 0.3724863965444541\n\njulia> all_cub_result.ENC.ENC\n3801-element Vector{Float64}:\n 56.787282202547104\n 52.725946690067296\n 59.287948966886226\n 52.29668642771212\n 55.26298060679466\n 53.44161579771853\n  ⋮\n 50.30390962534221\n 56.29539618087172\n 55.229391962859935\n 52.58401385627267\n 60.19275631834157","category":"page"},{"location":"cub/#Codon-Dictionaries","page":"Codon Usage Bias","title":"Codon Dictionaries","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"If you are working with genomes that use the standard genetic code, than feel free to skip this section - you should not need to worry about it. By default, CUBScout translates sequences using the standard code, as loaded in CUBScout.DEFAULT_CodonDict. However, if your sequences are translated differently, you will need to provide a custom codon dictionary to CUBScout. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Codon dictionaries are of a custom type CodonDict. You can use ?CodonDict to see the information this struct holds, which our codon usage bias functions need to correctly translate codons and calculate codon frequency. However, I recommend you do not construct a CodonDict manually, but instead make one using the make_CodonDict() function. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"make_CodonDict reads a plain text delimited file which lists the 64 codons and their corresponding amino acid. The file should look something like this:","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"AAA    Lysine\nAAC    Asparagine\nAAG    Lysine \n...    ...","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Please follow these formatting guidelines to make sure the table is parsed correctly:","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"The first column should be codons, and the second column their corresponding amino acid. \nDo not include headers and avoid trailing whitespace. \nCodons do not need to be alphabetized. \nAvoid spaces and special characters (e.g., write GlutamicAcid instead of Glutamic Acid). \nStop codons can be coded as Stop, stop, STOP, or *. \nIf delimited using any character outside of tab, supply the delimiter as the second argument as a Char, not a String (e.g. ',' not \",\"). ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"make_CodonDict uses readdlm from DelimitedFiles; it's a good idea to check whether readdlm parses your file correctly before passing to make_CodonDict.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"For demonstration purposes, CUBScout includes the delimited file used to construct the DEFAULT_CodonDict. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> CodonDict_PATH\n\"your/path/to/codon_dict.txt\"\n\njulia> our_CodonDict = make_CodonDict(CodonDict_PATH);\n\njulia> our_CodonDict.codons\n64-element Vector{BioSequences.LongSequence{BioSequences.DNAAlphabet{2}}}:\n AAA\n AAC\n AAG\n AAT\n[...]\n\njulia> our_CodonDict.AA\n64-element Vector{String}:\n \"Lysine\"\n \"Asparagine\"\n \"Lysine\"\n \"Asparagine\"\n [...]","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"You can supply your custom codon dictionary to any of the codon usage bias functions as the second argument.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> milc(EXAMPLE_DATA_PATH, our_CodonDict)\n(self = [0.49482573202153163, 0.5839439121281993, 0.49947166558087047, 0.6354929447434434, 0.5439352548027006, 0.6104721251245075, 0.6256398806438782, 0.6228376952086359, 0.5355298113407091, 0.7832276821181443  …  0.5968814155010973, 0.5964500002803941, 0.5930680822246766, 0.5412999510428169, 0.49866919389111675, 0.5830959504630727, 0.5139438478694085, 0.6164434557282711, 0.6018041071661588, 0.48775477465069617],)","category":"page"},{"location":"cub/#Alternative-Start-Codons","page":"Codon Usage Bias","title":"Alternative Start Codons","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"CUBScout provides three options to handle start codons outside of ATG. By default, alternative codons are translated as they would be anywhere else in the sequence. As such, TTG would be counted as leucine, even when in the first position.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"If you would like to disregard start codons entirely, set the argument rm_start = true. This will decrease the length of each gene sequence by one, but is my preferred method to dealing with alternative start codons.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Other packages to calculate codon usage bias, such as coRdon, handle alternative start codons differently. They encode all TTG and CTG codons as methionine, regardless of their location in the gene. While I disagree with this approach from a biological perspective, you can implement it using the pre-loaded ALTSTART_CodonDict. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> scuo_result = scuo(EXAMPLE_DATA_PATH, ALTSTART_CodonDict);\n\njulia> scuo_result.SCUO\n3801-element Vector{Float64}:\n 0.14286111587263958\n 0.19315278493814017\n 0.0966128845976179\n 0.3473543659821751\n 0.10792236840320082\n 0.12039525638448735\n ⋮\n 0.152064610300728\n 0.11200912387676948\n 0.18952246579743504\n 0.16473723774598686\n 0.24160824180945173","category":"page"},{"location":"cub/#Custom-Reference-Sets-with-ref_seqs","page":"Codon Usage Bias","title":"Custom Reference Sets with ref_seqs","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"B, ENC', MCB, and MILC all calculate an expected codon frequency using a reference set of the genome, and then calculate codon usage bias for each gene against that reference set. By default, this is the entire genome (\"self\"). However, you can provide your own reference subset(s) to these functions. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"First, you'll need a Boolean vector, whose length matches the number of sequences in your fasta file. Genes which you want included in your subset should be true; the rest of the vector should be false. One way to make this vector is with the find_seqs function to look for genes with specific functions.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> ribosomal_genes = find_seqs(EXAMPLE_DATA_PATH, r\"ribosomal\")\n4237-element Vector{Bool}:\n 0\n 0\n 0\n 0\n 0\n 0\n ⋮\n 0\n 0\n 0\n 0\n 1","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"tip: Tip\nCUBScout is designed not to hold the data from your fasta file as an object in your Julia environment. If you want to get sequence identifiers or descriptions outside of codon usage bias functions, there are the convenience functions seq_names and seq_descriptions:julia> seq_names(EXAMPLE_DATA_PATH)[1:5]\n5-element Vector{String}:\n \"lcl|NC_000964.3_cds_NP_387882.1_1\"\n \"lcl|NC_000964.3_cds_NP_387883.1_2\"\n \"lcl|NC_000964.3_cds_NP_387884.1_3\"\n \"lcl|NC_000964.3_cds_NP_387885.1_4\"\n \"lcl|NC_000964.3_cds_NP_387886.2_5\"\n\njulia> seq_descriptions(EXAMPLE_DATA_PATH)[1]\n\"lcl|NC_000964.3_cds_NP_387882.1_1 [gene=dnaA] [locus_tag=BSU_00010] [db_xref=EnsemblGenomes-Gn:BSU00010,EnsemblGenomes-Tr:CAB11777,GOA:P05648,InterPro:IPR001957,InterPro:IPR003593,InterPro:IPR010921,InterPro:IPR013159,InterPro:IPR013317,InterPro:IPR018312,InterPro:IPR020591,InterPro:IPR024633,InterPro:IPR027417,PDB:4TPS,SubtiList:BG10065,UniProtKB/Swiss-Prot:P05648] [protein=chromosomal replication initiator informational ATPase] [protein_id=NP_387882.1] [location=410..1750] [gbkey=CDS]\"","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Once you have your reference vector, you can supply an argument to ref_seqs as a named tuple. If you have multiple reference sets you want to use, those can be included as additional entries in the ref_seqs tuple.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> b_ribo_result = b(EXAMPLE_DATA_PATH, ref_seqs = (ribosomal = ribosomal_genes,));\n\njulia> b_ribo_result.ribosomal\n3801-element Vector{Float64}:\n 0.27433079214149625\n 0.3206897249908304\n 0.25532544766240484\n 0.5464925047248634\n 0.22424329272203575\n 0.22684609299155567\n ⋮\n 0.2561376033448253\n 0.2217345501228918\n 0.40667338789742696\n 0.3758568749612823\n 0.4379807676614555\n\njulia> dna_genes = find_seqs(EXAMPLE_DATA_PATH, r\"dna|DNA|Dna\")\n4237-element Vector{Bool}:\n 1\n 1\n 0\n 1\n 0\n 1\n ⋮\n 0\n 1\n 0\n 0\n 0\n\njulia> b_multi_result = b(EXAMPLE_DATA_PATH, ref_seqs = (ribosomal = ribosomal_genes, DNA = dna_genes));\n\njulia> b_multi_result.ribosomal\n3801-element Vector{Float64}:\n 0.27433079214149625\n 0.3206897249908304\n 0.25532544766240484\n 0.5464925047248634\n 0.22424329272203575\n 0.22684609299155567\n ⋮\n 0.2561376033448253\n 0.2217345501228918\n 0.40667338789742696\n 0.3758568749612823\n 0.4379807676614555\n\njulia> b_multi_result.DNA\n3801-element Vector{Float64}:\n 0.2148821062833632\n 0.3182032724315858\n 0.23577274334969703\n 0.5371269155669846\n 0.2684310325581909\n 0.2860168153422687\n ⋮\n 0.273137416897346\n 0.21136319951043495\n 0.3866134722044515\n 0.3510891124098759\n 0.3668966776242405","category":"page"},{"location":"cub/#Other-Arguments","page":"Codon Usage Bias","title":"Other Arguments","text":"","category":"section"},{"location":"cub/#rm_stop","page":"Codon Usage Bias","title":"rm_stop","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Whether to remove stop codons from the calculation of codon usage bias. Default is false","category":"page"},{"location":"cub/#threshold","page":"Codon Usage Bias","title":"threshold","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"The minimum length of a gene in codons to be used when calculating codon usage bias. The default is 80; all genes under that length are discarded. If you want to discard no genes, set threshold = 0. You do not need to adjust your reference sequence vector when adjusting threshold values.","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> b_result_0 = b(EXAMPLE_DATA_PATH, threshold = 0);\n\njulia> b_result_300 = b(EXAMPLE_DATA_PATH, threshold = 300);\n\njulia> length(b_result_0.self)\n4237\n\njulia> length(b_result_300.self)\n1650","category":"page"},{"location":"cub/#names","page":"Codon Usage Bias","title":"names","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"If providing a vector of BioSequences, CUBScout won't be able to provide identifiers for codon usage bias results. As such, you can optionally provide a vector of identifiers as an argument, and so you can link results to the original input sequences. ","category":"page"},{"location":"cub/#Analyzing-Multiple-Files","page":"Codon Usage Bias","title":"Analyzing Multiple Files","text":"","category":"section"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"Often, you might have a directory containing multiple .fna files, each of which you want to analyze. You can provide a vector of filepaths (or FASTAReaders, or IOStreams) to any CUBScout function, which will return a vector of results. If using BioSequences, each vector of sequences is considered a genome; if you provide a Vector{<:Vector{<:NucSeq}}, this will function the same as providing multiple filepaths. If supplying ref_seqs, provide a vector of named tuples corresponding to each file. The same goes for providing names - provide a Vector{Vector{String}} where each vector of names corresponds to each vector of Biosequences. CUBScout is multi-threaded, and if Julia is started with multiple threads, will assign individual threads to process individual files. This means you should not broadcast CUBScout codon usage bias functions as it will reduce efficiency. Also each file is only ever processed by a single thread, so using more threads than you have files is unnecessary. ","category":"page"},{"location":"cub/","page":"Codon Usage Bias","title":"Codon Usage Bias","text":"julia> enc_p([EXAMPLE_DATA_PATH,EXAMPLE_DATA_PATH])\n2-element Vector{Any}:\n self = [61.0, 59.36979815371983, 60.7494622549966, 61.0, ...],\n Identifier = [\"lcl|NC_000964.3_cds_NP_387882.1_1\", \"lcl|NC_000964.3_cds_NP_387883.1_2\", ...]),\n self = [61.0, 59.36979815371983, 60.7494622549966, 61.0, ...],\n Identifier = [\"lcl|NC_000964.3_cds_NP_387882.1_1\", \"lcl|NC_000964.3_cds_NP_387883.1_2\", ...])\n\njulia> enc_p([EXAMPLE_DATA_PATH,EXAMPLE_DATA_PATH], ref_seqs = [(ribosomal = ribosomal_genes,), (ribosomal = ribosomal_genes,)])\n2-element Vector{Any}:\n self = [61.0, 58.88817312982425, 56.41038374603565, 61.0, ...],\n Identifier = [\"lcl|NC_000964.3_cds_NP_387882.1_1\", \"lcl|NC_000964.3_cds_NP_387883.1_2\", ...]),\n self = [61.0, 58.88817312982425, 56.41038374603565, 61.0, ...],\n Identifier = [\"lcl|NC_000964.3_cds_NP_387882.1_1\", \"lcl|NC_000964.3_cds_NP_387883.1_2\", ...])","category":"page"},{"location":"codons/#Counting-Codons-and-Calculating-Codon-Frequency","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"In the process of calculating codon usage bias, CUBScout developed some handy functions for counting codons, calculating codon frequency, and sorting through a fasta file. These accessory functions underlie the codon usage bias functions, but are available to users as well. If you just want to calculate codon usage bias, you won't need to interact with these functions and can skip this section.","category":"page"},{"location":"codons/#Counting-Codons","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"The first step in calculating codon usage bias is counting the occurence of each codon within each coding sequence. The count_codons performs this function quickly and can accept numerous datatypes.","category":"page"},{"location":"codons/#Inputs-and-Outputs","page":"Counting Codons and Calculating Codon Frequency","title":"Inputs and Outputs","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"count_codons can accept a filepath to a fasta file of sequences, an IOStream, an open FASTAReader, or a BioSequences nucleotide sequence, or a vector of nucleotide sequences. If providing a single sequence, the result will be a 64x1 Matrix, which corresponds to the 64 codons in alphabetical order. If you want a list of the codons in alphabetical order, this is stored in CUBScout.DEFAULT_CodonDict.codons. If analyzing a fasta file or a vector of sequences, the result will be a tuple. The first element of the tuple is a 64xn matrix, where n is the number of sequences above the threshold. The second element is a vector of names corresponding to each column. The third element is a Boolean vector where true corresponds to sequences which did pass the threshold, and false is sequences which did not pass the threshold and so are not included in the results matrix. ","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"CUBScout is loaded with an example dataset, which can accessed at CUBScout.EXAMPLE_DATA_PATH. This string points to a .fna of coding sequences from B. subtilis. Let's go aheand and run count_codons on our example data set:","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"julia> result = count_codons(EXAMPLE_DATA_PATH);\n\njulia> size(result[1])\n(64, 4237)\n\njulia> first(result[1], 5)\n5-element Vector{Int32}:\n 32\n  7\n  6\n 14\n 11\n\njulia> first(result[2], 5)\n5-element Vector{String}:\n \"lcl|NC_000964.3_cds_NP_387882.1_1\"\n \"lcl|NC_000964.3_cds_NP_387883.1_2\"\n \"lcl|NC_000964.3_cds_NP_387884.1_3\"\n \"lcl|NC_000964.3_cds_NP_387885.1_4\"\n \"lcl|NC_000964.3_cds_NP_387886.2_5\" ","category":"page"},{"location":"codons/#rm_stop","page":"Counting Codons and Calculating Codon Frequency","title":"rm_stop","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"Whether to remove the first codon. A more thorough discussion of CUBScout's treatment of start codons can be found in the Codon Usage Bias section \"Alternative Start Codons\". ","category":"page"},{"location":"codons/#threshold","page":"Counting Codons and Calculating Codon Frequency","title":"threshold","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"This is the minimum length of a sequence, in codons, to be included in the results. If you would like all sequences analyzed, this can be set to 0. If a sequence does not pass the threshold, it won't be included in the results matrix, and its identifier won't be included in the names vector. As we increase the threshold, our matrix becomes smaller as sequences are filtered out:","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"julia> result_300 = count_codons(EXAMPLE_DATA_PATH, false, 300);\n\njulia> size(result_300[1])\n(64, 1650)","category":"page"},{"location":"codons/#names","page":"Counting Codons and Calculating Codon Frequency","title":"names","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"When using count_codons on a fasta file, identifiers are automatically pulled from the sequence headers. However, if providing a vector of BioSequences, there aren't names linked to each sequence, and instead might be stored in a separate vector of the same length. Because count_codons removes sequences below the threshold, this poses a quandary: how do you know which sequences were kept and which were removed? By providing a names vector to count_codons, as sequences are discarded, their corresponding identifiers will also be discarded from the results. This is an optional argument, and is only relevant if providing Vector{<:NucSeq} as an argument. For this reason, however, count_codons dispatches on kwargs if provided a Vector{<:NucSeq} instead of position.","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"julia> using BioSequences: @dna_str\n\njulia> example_dna1 = dna\"ATGAAAATGAACTTTTGA\"\n18nt DNA Sequence:\nATGAAAATGAACTTTTGA\n\njulia> count_codons(example_dna)\n64×1 Matrix{Int64}:\n 1\n 1\n 0\n 0\n 0\n ⋮\n 0\n 0\n 0\n 0\n 1\n\njulia> example_dna2 = dna\"ATGAAAATGAACTTTTGAATGAAAATGAACTTTTGAATGAAAATGAACTTTTGA\"\n54nt DNA Sequence:\nATGAAAATGAACTTTTGAATGAAAATGAACTTTTGAATGAAAATGAACTTTTGA\n\njulia> count_codons([example_dna1, example_dna2])\n(Int32[1 3; 1 3; … ; 0 0; 1 3], nothing, Bool[1, 1])\n\njulia> count_codons([example_dna1, example_dna2], threshold = 8)\n(Int32[3; 3; … ; 0; 3;;], nothing, Bool[0, 1])\n\njulia> count_codons([example_dna1, example_dna2], threshold = 8, names = [\"Example1\",\"Example2\"])\n(Int32[3; 3; … ; 0; 3;;], [\"Example2\"], Bool[0, 1])","category":"page"},{"location":"codons/#Codon-Frequency","page":"Counting Codons and Calculating Codon Frequency","title":"Codon Frequency","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"Once you've counted your codons, you may want to calculate the frequency at which each codon occurs. codon_frequency accepts a count matrix from count_codons and calculates codon frequency. The input must be a 64xn matrix of integers, where each row corresponds to the 64 codons in order, and each column corresponds do a gene sequence (note, this is why count_codons returns a 64x1 Matrix when run on a single sequence, rather than a vector). ","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"There are four ways to calculate codon frequency. Let's use an example to illustrate their differences by making a mock genome with two genes in it.","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"julia> gene1 = dna\"AAAAAGAAATTT\"\n12nt DNA Sequence:\nAAAAAGAAATTT\n\njulia> gene2 = dna\"AAGAAGTTTTTCTTC\"\n15nt DNA Sequence:\nAAGAAGTTTTTCTTC\n\njulia> genome = [gene1, gene2]\n2-element Vector{LongSequence{DNAAlphabet{4}}}:\n AAAAAGAAATTT\n AAGAAGTTTTTCTTC\n\njulia> count_codons(genome)\n(Int32[2 0; 0 0; … ; 0 0; 1 1], nothing, Bool[1, 1])\n\njulia> count_result = count_codons(genome)\n(Int32[2 0; 0 0; … ; 0 0; 1 1], nothing, Bool[1, 1])\n\njulia> count_matrix = count_result[1]\n64×2 Matrix{Int32}:\n 2  0\n 0  0\n 1  2\n 0  0\n 0  0\n ⋮  \n 0  0\n 0  0\n 0  2\n 0  0\n 1  1","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"We can see that gene1 had two counts of AAA (row 1), one of AAG (row 3), and one of TTT (row 64). For gene2, we have 2 counts of AAG, 2 counts of TTC (row 62), and 1 count of TTT. AAA and AAG code for lysine, while TTT and TTC code for phenylalanine.","category":"page"},{"location":"codons/#net_genomic","page":"Counting Codons and Calculating Codon Frequency","title":"net_genomic","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"This will calculate the cumulative codon frequency of each codon across the entire matrix (genome), as a percentage of all codon counts in the matrix. So for example:","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"julia> codon_frequency(count_matrix, \"net_genomic\")\n64×1 Matrix{Float64}:\n 0.2222222222222222\n 0.0\n 0.3333333333333333\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n 0.2222222222222222\n 0.0\n 0.2222222222222222","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"Across our entire genome, we counted 9 codons. AAA, TTC, and TTT all had two counts, and so at rows 1, 62, and 64 we have 0.222 = 2/9. AAG occurred three times, so we have 0.33 at row 3. ","category":"page"},{"location":"codons/#net_gene","page":"Counting Codons and Calculating Codon Frequency","title":"net_gene","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"This will calculate the codon frequency within each gene (column) in the matrix, as a percentage of all codon counts in that gene.","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"julia> codon_frequency(count_matrix, \"net_gene\")\n64×2 Matrix{Float64}:\n 0.5   0.0\n 0.0   0.0\n 0.25  0.4\n 0.0   0.0\n 0.0   0.0\n ⋮     \n 0.0   0.0\n 0.0   0.0\n 0.0   0.4\n 0.0   0.0\n 0.25  0.2","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"First, we now have a matrix instead of a vector, because we are now getting results for each gene instead of summarized across the genome. There were 4 codons in gene 1. There were two counts of AAA, so its codon frequency was 0.5 = 2/4 (row 1). AAG and TTT both had a by-gene frequency of 0.25.  There were 5 codons in gene 2. Both AAG (row 3) and TTC (row 62) had 2 counts, so had a by-gene frequency of 0.4 = 2/5.","category":"page"},{"location":"codons/#byAA_genomic","page":"Counting Codons and Calculating Codon Frequency","title":"byAA_genomic","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"This will calculate the codon frequency of each codon within each amino acid across the entire matrix (genome). Let's see what happens in this scenario in our mock genome:","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"julia> codon_frequency(count_matrix, \"byAA_genomic\")\n64-element Vector{Real}:\n 0.4\n 0\n 0.6\n 0\n 0\n ⋮\n 0\n 0\n 0.5\n 0\n 0.5","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"Because we've summarized across the genome we're back to a vector as output. We had 5 codons which coded for lysine across the genome. If we look at our lysine codons (AAA and AAG), we see AAA had a byAA genomic frequency of 0.4 = 2 / 5, while AAG had a byAA genomic frequency of 0.6 = 3/5. For our phenylalanine codons (TTC and TTT), they both occurred twice across the genome, and so had a byAA genomic frequency of 0.5.","category":"page"},{"location":"codons/#byAA_gene","page":"Counting Codons and Calculating Codon Frequency","title":"byAA_gene","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"Finally, we can calculate the codon frequency of each codon within each amino acid within each gene. For example:","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"julia> codon_frequency(count_matrix, \"byAA_gene\")\n64×2 Matrix{Real}:\n 0.666667  0.0\n 0         0\n 0.333333  1.0\n 0         0\n 0         0\n ⋮         \n 0         0\n 0         0\n 0.0       0.666667\n 0         0\n 1.0       0.333333","category":"page"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"If we look at gene1 (column 1), it exclusively used TTT to code for phenylalanine, but used AAA to code for lysine 66% of the time. In contrast, gene2 used AAG to code for lysine 100% of the time. ","category":"page"},{"location":"codons/#Codon-Dictionarys","page":"Counting Codons and Calculating Codon Frequency","title":"Codon Dictionarys","text":"","category":"section"},{"location":"codons/","page":"Counting Codons and Calculating Codon Frequency","title":"Counting Codons and Calculating Codon Frequency","text":"If calculating byAA codon frequencies, codons need to be translated into amino acids, which is done by supplying a codon dictionary. A more complete description of codon dictionaries, including using alternative genetic codes, can be found in the Codon Usage Bias section \"Codon Dictionaries\".","category":"page"},{"location":"inputs/#Providing-Inputs-to-CUBScout","page":"Providing Inputs to CUBScout","title":"Providing Inputs to CUBScout","text":"","category":"section"},{"location":"inputs/#Genomes-and-CDSs","page":"Providing Inputs to CUBScout","title":"Genomes and CDSs","text":"","category":"section"},{"location":"inputs/","page":"Providing Inputs to CUBScout","title":"Providing Inputs to CUBScout","text":"First, CUBScout only works with coding sequences. CUBScout does not identify ORFs, pause at stop codons, or parse non-nucleotide characters. It is assumed the coding sequences you provide are in-frame and don't contain 5' or 3' untranslated regions. Codons which have non-specific nucleotides, like \"W\", are skipped.  Sequences with characters outside of those recognized by BioSequences will throw an error. ","category":"page"},{"location":"inputs/","page":"Providing Inputs to CUBScout","title":"Providing Inputs to CUBScout","text":"Some CUBScout functions, like count_codons, are meaningful when applied to a single nucleotide sequence. However, most CUBScout functions are designed to work at the genome-level, and calculate metrics that rely on comparisons between multiple genes. Specifically, none of the codon usage bias or expressivity functions accept a single nucleotide sequence; all expect to operate across a set of sequences, whether in a fasta file or vector of BioSequences.","category":"page"},{"location":"inputs/#FASTA-Files","page":"Providing Inputs to CUBScout","title":"FASTA Files","text":"","category":"section"},{"location":"inputs/","page":"Providing Inputs to CUBScout","title":"Providing Inputs to CUBScout","text":"Most functions in CUBScout accept any FASTA-formatted file (e.g. .fa, .fna, .fasta) where each entry corresponds to coding sequences or open readings frames. CUBScout accepts either a String which is the complete filepath to a fast-formatted file, or objects of type FASTAReader or IO which point to a fasta-formatted file. There is no significant performance advantage between these three options, unless you already have an IOStream or FASTAReader open for another purpose. ","category":"page"},{"location":"inputs/#BioSequences","page":"Providing Inputs to CUBScout","title":"BioSequences","text":"","category":"section"},{"location":"inputs/","page":"Providing Inputs to CUBScout","title":"Providing Inputs to CUBScout","text":"CUBScout functions also accept nucleotide sequences from BioSequences (<:NucSeq). Keep in mind that most CUBScout functions are designed to operate across genomes, and so accept a vector of nucleotide sequences. The vector corresponds to a genome, with each DNA or RNA string corresponding to a coding sequence.","category":"page"},{"location":"inputs/","page":"Providing Inputs to CUBScout","title":"Providing Inputs to CUBScout","text":"While there is a slight performance advantage in CUBScout functions when supplying BioSequences as an input rather than a filepath, supplying filepaths will still be faster than the cumulative time spent reading in a BioSequence and then running a CUBScout function. This will also use less memory and so is generally recommended, unless you already have BioSequences loaded into Julia's environment for a separate reason.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = CUBScout","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: header)","category":"page"},{"location":"#**C**odon-**U**sage-**B**ias-in-Julia","page":"Introduction","title":"Codon Usage Bias in Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CUBScout calculates Codon Usage Bias (CUB) and related expressivity predictions. Currently, CUBScout calculates:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Six measures of codon usage bias:\nB, from Karlin and Mrazek, 1996\nENC, from Wright 1990\nENC', from Novembre, 2002\nMCB, from Urrutia and Hurst, 2001\nMILC, from Supek and Vlahovicek, 2005\nSCUO, from Wan et al., 2004\nFive expressivity measures based on codon usage bias:\nCAI, from Sharp and Li, 1987\nE, from Karlin and Mrazek, 1996\nFOP, from Ikemura, 1981\nGCB, from Merkl, 2003\nMELP, from Supek and Vlahovicek, 2005","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CUBScout is based off of the fabulous coRdon package in R by Anamaria Elek, Maja Kuzman, and Kristian Vlahovicek. I am grateful for their clear code and would encourage you to cite coRdon as well when using CUBScout.","category":"page"},{"location":"reference/#References","page":"References","title":"References","text":"","category":"section"},{"location":"reference/","page":"References","title":"References","text":"Elek A, Kuzman M, Vlahovicek K (2023). coRdon: Codon Usage Analysis and Prediction of Gene Expressivity. R package version 1.18.0, https://github.com/BioinfoHR/coRdon.","category":"page"},{"location":"reference/","page":"References","title":"References","text":"Ikemura, T., 1981. Correlation between the abundance of Escherichia coli transfer RNAs and the occurrence of the respective codons in its protein genes: a proposal for a synonymous codon choice that is optimal for the E. coli translational system. Journal of molecular biology, 151(3), pp.389-409.","category":"page"},{"location":"reference/","page":"References","title":"References","text":"Karlin, S. and Mrázek, J., 1996. What drives codon choices in human genes?. Journal of molecular biology, 262(4), pp.459-472.","category":"page"},{"location":"reference/","page":"References","title":"References","text":"Merkl, R., 2003. A survey of codon and amino acid frequency bias in microbial genomes focusing on translational efficiency. Journal of molecular evolution, 57, pp.453-466.","category":"page"},{"location":"reference/","page":"References","title":"References","text":"Novembre, J.A., 2002. Accounting for background nucleotide composition when measuring codon usage bias. Molecular biology and evolution, 19(8), pp.1390-1394.","category":"page"},{"location":"reference/","page":"References","title":"References","text":"Sharp, P.M. and Li, W.H., 1987. The codon adaptation index-a measure of directional synonymous codon usage bias, and its potential applications. Nucleic acids research, 15(3), pp.1281-1295.","category":"page"},{"location":"reference/","page":"References","title":"References","text":"Supek, F. and Vlahoviček, K., 2005. Comparison of codon usage measures and their applicability in prediction of microbial gene expressivity. BMC bioinformatics, 6, pp.1-15.","category":"page"},{"location":"reference/","page":"References","title":"References","text":"Urrutia, A.O. and Hurst, L.D., 2001. Codon usage bias covaries with expression breadth and the rate of synonymous evolution in humans, but this is not evidence for selection. Genetics, 159(3), pp.1191-1199.","category":"page"},{"location":"reference/","page":"References","title":"References","text":"Wan, X.F., Xu, D., Kleinhofs, A. and Zhou, J., 2004. Quantitative relationship between synonymous codon usage bias and GC composition across unicellular genomes. BMC Evolutionary Biology, 4, pp.1-11.","category":"page"},{"location":"reference/","page":"References","title":"References","text":"Wright, F., 1990. The ‘effective number of codons’ used in a gene. Gene, 87(1), pp.23-29.","category":"page"}]
}
